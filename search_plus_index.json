{"./":{"url":"./","title":"Introduction","keywords":"","body":"3d-study-notes to record key knowledge points about 3d 用于记录 3D 相关开发过程中碰到的各种奇奇怪怪的问题和解决方案 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-24 10:57:56 "},"pages/threeJS/":{"url":"pages/threeJS/","title":"Basic","keywords":"","body":"threeJS 基础知识 形状：Geometry 材质：Material 模型：Geometries = new THREE.Mesh(geometry, material) 光源：Light 场景：Scene: Scene.add(Light) Scene.add(Geometries) 相机：Camera 渲染器：renderer: renderer.render(scene, camera) => document.body.appendChild(renderer.domElement) 扩展控件：Controls: OrbitControls + Controls 加载器：Loaders 主要流程 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/threeJS/Math/":{"url":"pages/threeJS/Math/","title":"Math","keywords":"","body":"Math 数学相关 1.向量相关 基础知识 向量在图形学中的表示 向量可以用其次坐标来表示 A = \\begin{bmatrix} X\\\\ Y\\\\ \\end{bmatrix} 向量的转置 A^T = \\begin{bmatrix} X&Y\\\\ \\end{bmatrix} 向量长度的计算 ||\\vec A|| = \\sqrt{X^2+Y^2} 向量相加（add）: 平行四边形法则或者三角形法则 向量的运算 a.向量点乘（dot） \\vec a · \\vec b = ||\\vec a||||\\vec b||cos\\theta 向量点乘后得到的结果是一个数值 for 2D \\vec a · \\vec b = \\begin{bmatrix} x_a\\\\ y_a\\\\ \\end{bmatrix} · \\begin{bmatrix} x_b\\\\ y_b\\\\ \\end{bmatrix} = x_ax_b + y_ay_b for 3D \\vec a · \\vec b = \\begin{bmatrix} x_a\\\\ y_a\\\\ z_a\\\\ \\end{bmatrix} · \\begin{bmatrix} x_b\\\\ y_b\\\\ z_b\\\\ \\end{bmatrix} = x_ax_b + y_ay_by + z_az_b 几何意义: 表征或计算两个向量之间的夹角：如果向量 a 和 b 是单位向量，cos\\theta = \\vec a · \\vec b b 向量在 a 向量方向上的投影 向量点乘在图形学中的实际应用 计算两个向量的夹角：比如计算光照方向和物体表面之间的夹角 投影阴隐的计算 把一个向量分解为两个垂直方向上的向量 向量点乘的正负可以表示两个向量的方向是否接近：比如金属的高光反射，不接近就看不到反射的光。 向量点乘满足交化率结合律和分配率 b.向量叉乘（cross） \\vec a x \\vec b = ||\\vec a||||\\vec b||sin\\theta 向量点乘后得到的结果是一个向量 数字大小 \\vec a x \\vec b = \\begin{bmatrix} y_az_b - y_bz_a\\\\ z_ax_b - x_az_b\\\\ x_ay_b - y_ax_b\\\\ \\end{bmatrix} = \\begin{bmatrix} 0&-z_a&y_a\\\\ z_a&0&-x_a\\\\ -y_a&x_a&0\\\\ \\end{bmatrix}\\begin{bmatrix} x_b\\\\ y_b\\\\ z_b\\\\ \\end{bmatrix} 行列式推导过程：https://blog.csdn.net/qq_36286039/article/details/124141634 方向：右手螺旋定则 \\vec X x \\vec Y = +\\vec Z \\vec Y x \\vec X = -\\vec Z 几何意义 方向的意义：可以通过两个向量的叉乘，生成第三个垂直于a，b的法向量，从而构建X、Y、Z坐标系 数值的意义：在二维空间中，叉乘还有另外一个几何意义就是：aXb等于由向量a和向量b构成的平行四边形的面积。 向量点乘在图形学中的实际应用 判定左和右：比如判断向量 a 在向量 b 的左侧还是右侧 判定里和外：比如判断一个点是否在一个三角形的内部 面积计算：比如计算复杂几何体的表面积 向量点乘不满足交化率，但是满足结合律和分配率 2.矩阵相关 矩阵乘法口诀：左取行，右取列，相乘再相加，行列定位置。 向量点乘不满足交化率，但是满足结合律和分配率 a.矩阵乘法合法性 A = \\begin{bmatrix} 2&4\\\\ 6&8\\\\ -2&-3\\\\ \\end{bmatrix} B = \\begin{bmatrix} 2&4&6&1\\\\ 6&4&1&3\\\\ \\end{bmatrix} 我们能不能把它们相乘得到 AB 必须满足一个条件：A 矩阵的列数必须等于 B 矩阵的行数。 b.矩阵的转置 行列转置 \\begin{bmatrix} 2&4&1\\\\ 6&5&3\\\\ \\end{bmatrix}^T = \\begin{bmatrix} 2&6\\\\ 4&5\\\\ 1&3\\\\ \\end{bmatrix} 特性 (AB)^T = B^TA^T c.矩阵在图形学中的实际应用 矩阵乘以向量：向量必须是一个列向量，实际就是我们的变换。 矩阵乘法结合律：比如视图矩阵乘以投影矩阵。 d.矩阵变换 平移 \\begin{bmatrix} 1&0&0&t_x\\\\ 0&1&0&t_y\\\\ 0&0&1&t_z\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} x+t_x\\\\ y+t_y\\\\ z+t_z\\\\ 1\\\\ \\end{bmatrix} 缩放 \\begin{bmatrix} s_x&0&0&0\\\\ 0&s_y&0&0\\\\ 0&0&s_z&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} s_x·x\\\\ s_y·y\\\\ s_z·z\\\\ 1\\\\ \\end{bmatrix} 旋转 绕x轴旋转α度对应的旋转矩阵Rx \\begin{bmatrix} 1&0&0&0\\\\ 0&cosα&-sinα&0\\\\ 0&sinα&cosα&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} x\\\\ cosα*y-sinα*z\\\\ sinα*y+cosα*z\\\\ 1\\\\ \\end{bmatrix} 绕y轴旋转α度对应的旋转矩阵Ry \\begin{bmatrix} cosα&0&-sinα&0\\\\ 0&1&0&0\\\\ sinα&0&cosα&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} cosα*x+sinα*z\\\\ y\\\\ -sinα*x+cosα*z\\\\ 1\\\\ \\end{bmatrix} 绕z轴旋转α度对应的旋转矩阵Rz \\begin{bmatrix} cosα&-sinα&0&0\\\\ sinα&cosα&0&0\\\\ 0&0&1&0\\\\ 0&0&0&1\\\\ \\end{bmatrix} * \\begin{bmatrix} x\\\\ y\\\\ z\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} cosα*x-sinα*y\\\\ sinα*x+cosα*y\\\\ z\\\\ 1\\\\ \\end{bmatrix} 3.欧拉对象 Euler、四元数 Quaternion 和旋转矩阵 欧拉对象、四元数和旋转矩阵都是用来表达对象的旋转信息。欧拉对象和四元数存在的意义：为了给旋转变换做插值。 https://threejs.org/docs/#api/zh/math/Euler https://threejs.org/docs/#api/zh/math/Quaternion // Euler( x : Float, y : Float, z : Float, order : String ) // x - (optional) 用弧度表示x轴旋转量。 默认值是 0。 // y - (optional) 用弧度表示y轴旋转量。 默认值是 0。 // z - (optional) 用弧度表示z轴旋转量。 默认值是 0。 // order - (optional) 表示旋转顺序的字符串，默认为'XYZ'（必须是大写）。 const Euler = new THREE.Euler( Math.PI/4, 0, Math.PI/2, 'XYZ'); Euler.x = Math.PI/4; Euler.y = Math.PI/2; Euler.z = Math.PI/4; Euler.order = 'YZX' // 绕单位向量Vector3(x, y, z) 表示的轴旋转 θ 度 // k = sinθ/2 // q = ( xk , yk , z*k, cosθ/2) // 【下面的例子是：将点(0, 0, 1)绕 Y 轴旋转 90 度，得到新的坐标(1, 0, 0)】 const quaternion = new THREE.Quaternion(); // 旋转轴 new THREE.Vector3(0, 1, 0) // 旋转角度 Math.PI / 2 const angle = Math.PI / 2 quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle) console.log('查看四元数结构', quaternion); const k = Math.sin(angle / 2) console.log('查看数组', [0 * k , 1 * k , 0 * k, Math.cos(angle / 2)]); const vector = new THREE.Vector3( 0, 0, 1 ); const newVector = vector.clone().applyQuaternion( quaternion ); console.log('旋转后的新坐标', newVector) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-07-10 14:20:21 "},"pages/threeJS/Pipeline/":{"url":"pages/threeJS/Pipeline/","title":"Graphics Pipeline","keywords":"","body":"图形管线（Graphics Pipeline） 图形管线（Graphics Pipeline）是一系列的图形处理阶段，用于将输入的几何数据转换为最终的图像输出。它是图形渲染的核心流程，负责对图形对象进行处理、变换和渲染，以生成最终的可视化结果。 通常情况下，图形管线包括以下主要阶段： 几何阶段（Geometry Stage）：该阶段负责处理输入的几何数据，例如顶点坐标、法线和纹理坐标等。在几何阶段中，可以进行顶点变换、投影变换、裁剪、三角形划分和顶点属性插值等操作。 光栅化阶段（Rasterization Stage）：在光栅化阶段，将三维几何图形转化为二维的光栅图像。它将三角形片元化为像素，并确定每个像素的位置和相关属性，如颜色、深度和纹理坐标等。 片元着色阶段（Pixel Shader Stage）：在片元着色阶段，为每个片元（像素）计算其最终的颜色值。这包括应用光照模型、纹理映射、阴影计算和透明度等。片元着色阶段是实现光照、纹理和其他视觉效果的关键环节。 输出合成阶段（Output Merger Stage）：输出合成阶段将经过片元着色阶段的片元颜色和深度值合成为最终的图像输出。在此阶段，还可以进行混合（Blending）、深度测试（Depth Testing）和模板测试（Stencil Testing）等操作。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-06-14 16:23:51 "},"pages/threeJS/Transform/":{"url":"pages/threeJS/Transform/","title":"Transform","keywords":"","body":"变换 图形学中的变换主要包含：视图变换（View Transformation）和投影变换（Projection Transformation） 视图变换是指从世界坐标系到相机坐标系的变换过程。视图变换是为了模拟相机在三维空间中的位置和方向，并决定了观察者在场景中看到的视图。通过视图变换，可以实现相机的移动、旋转和缩放等操作，以改变观察者的视角和观察到的场景。 投影变换是指将相机坐标系中的三维点投影到二维屏幕空间的过程。投影变换可以使用正交投影或透视投影来实现。 区别：视图变换主要关注相机位置和方向的变换，以及观察者的视角；而投影变换主要关注将三维点从相机坐标系投影到二维屏幕坐标系的过程，考虑透视效果和投影方式的影响。 齐次坐标（Homogeneous Coordinates） 齐次坐标没那么复杂，通过引入额外的维度（w-coordinate），让平移也能像旋转和缩放一样写成 3 x 3 的矩阵。 笛卡尔坐标系中，平移不是线性变换，不能写入矩阵中： \\begin{bmatrix} x_a\\\\ y_a\\\\ \\end{bmatrix} = \\begin{bmatrix} a & b\\\\ c & d\\\\ \\end{bmatrix} · \\begin{bmatrix} x\\\\ y\\\\ \\end{bmatrix} + \\begin{bmatrix} t_x\\\\ t_y\\\\ \\end{bmatrix} 使用其次坐标： \\begin{bmatrix} x_a\\\\ y_a\\\\ 1\\\\ \\end{bmatrix} = \\begin{bmatrix} a & b & t_x\\\\ c & d & t_y\\\\ 0 & 0 & 1\\\\ \\end{bmatrix} · \\begin{bmatrix} x\\\\ y\\\\ 1\\\\ \\end{bmatrix} w 为1时，表示点；w 为0时，表示向量: 2D point = \\begin{bmatrix} x\\\\ y\\\\ 1\\\\ \\end{bmatrix} 2D vector = \\begin{bmatrix} x\\\\ y\\\\ 0\\\\ \\end{bmatrix} 在齐次坐标中，对 w 坐标的理解： vector + vector = vector point – point = vector point + vector = point point + point = ?? （取中点） 2D 变换矩阵（2D Transformation Matrices） 2D 变换矩阵中，平移和旋转都很简单，不好推导的是旋转矩阵 R(α) = \\begin{bmatrix} cosα & -sinα & 0\\\\ sinα & cosα & 0\\\\ 0 & 0 & 1\\\\ \\end{bmatrix} 组合变换（S1：缩放；T2：平移；R3：旋转），类似 js 中的 compose 函数。 R3(T2(S1(X))) = R3 · T2 · S1 · \\begin{bmatrix} x\\\\ y\\\\ 1\\\\ \\end{bmatrix} 视图变换（View Transformation） 视图变换只涉及到平移和旋转： 将相机的位置旋转到坐标原点； 将相机向上的方向旋转到 Y 方向； 将相机看向的方向旋转到 -Z 方向； 如果相机的位置默认就在坐标原点，向上方向为 Y 方向，并且看向的方向是 -Z 方向，那么视图矩阵就是一个单位矩阵。 投影变换（Projection Transformation） 投影变换是指将相机坐标系中的三维点投影到二维屏幕空间的过程 正交投影（Orthographic Projection） 正交投影只涉及到平移和缩放： 将中心平移到坐标原点； 缩放到标准立方体(canonical cube)：[-1, 1]^3 透视投影（Perspective Projection） 在正交投影的基础上，再乘以一个新的矩阵，从而实现近大远小的效果，这个矩阵推导有点复杂。 THREE.JS 中的视图矩阵和投影矩阵 在 THREE.JS 中，视图矩阵和投影矩阵都被封装到 camera 中。 const viewMatrix = camera.matrixWorldInverse; const projectionMatrix = camera.projectionMatrix; console.log('View Matrix:', viewMatrix); console.log('Projection Matrix:', projectionMatrix); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-07-10 15:38:22 "},"pages/threeJS/Rasterization/":{"url":"pages/threeJS/Rasterization/","title":"Rasterization","keywords":"","body":"光栅化（Rasterization） 在计算机图形学中，光栅化是将连续的几何形状和属性转换为离散像素的过程。在光栅化的过程中，取样是其中的核心概念之一。 取样（Sampling） for (int x = 0; x inside 函数 向量叉乘右手螺旋定则： \\vec {AB} · \\vec {AQ} 方向为正，代表 Q 在 \\vec {AB} 的左侧 \\vec {BC} · \\vec {BQ} 方向为正，代表 Q 在 \\vec {BC} 的左侧 \\vec {CA} · \\vec {CQ} 方向为负，代表 Q 在 \\vec {CA} 的右侧 三个叉乘方向不同，所以 Q 在三角形 ABC 的外部 取样瑕疵（Sampling Artifacts） 锯齿：Jaggies – sampling in space 摩尔纹：Moire – undersampling images 车轮效应：Wagon wheel effect – sampling in time 抗锯齿（Antialias） 锯齿产生的原因 个人理解：把图像看成信号，图像信号频率变化太快，但是光栅化采样太慢，形成了空缺，图像不连续，形成了锯齿。 一个词解释：undersampling：采样过疏 抗锯齿的方法 光栅化采样之前，先对图像边缘进行模糊处理。 抗锯齿原理解析 傅里叶变换 卷积理论 实际开发中的抗锯齿 webGL const context = canvas.getContext('webgl', { antialias: true }); THREE.js const renderer = new THREE.WebGLRenderer({ antialias: true }); // or const renderer = new THREE.WebGLRenderer(); renderer.domElement.style.imageRendering = 'auto'; renderer.domElement.style.imageRendering = 'crisp-edges'; renderer.domElement.style.imageRendering = 'pixelated'; 抗锯齿方法汇总 多重采样抗锯齿（Multisample Anti-Aliasing，MSAA）：MSAA 是一种硬件加速的抗锯齿技术。它使用多个采样点来对图像进行抗锯齿处理，每个采样点记录一些像素的颜色和深度信息。通过对这些采样点进行插值，可以减少锯齿状边缘的出现。MSAA 是一种高质量的抗锯齿方法，但它会增加计算开销和内存消耗。 快速近似抗锯齿（Fast Approximate Anti-Aliasing，FXAA）：FXAA 是一种基于后处理的抗锯齿技术，它通过对整个图像进行分析和处理来减少锯齿状边缘。FXAA 使用了一些启发式算法和模糊技术，通过对锯齿边缘进行模糊处理来实现抗锯齿效果。FXAA 的优点是速度快，但可能会导致一些图像细节的损失。 时域抗锯齿（Temporal Anti-Aliasing，TAA）：TAA 是一种基于时间上的抗锯齿技术，它结合了帧之间的信息来减少锯齿状边缘。TAA 利用了连续帧之间的运动和像素颜色变化的关系，通过对多个帧进行混合和插值来消除锯齿。TAA 可以提供高质量的抗锯齿效果，并且对运动和细节保持较好的处理能力，但它可能会引入一些运动模糊或图像伪影。 深度测试（Z-buffer） 画家算法 基于图形的算法：先画远处的图形，再画近处的图形。 三个三角形相互遮挡的情形，无法处理。 Z-buffer Z-buffer 算法过程 在渲染场景之前，创建一个与屏幕分辨率相同的深度缓冲区（Z-Buffer），用于存储每个像素的深度值。 对于每个要渲染的物体，按照其离相机的距离进行排序。通常使用物体的中心点距离相机的距离作为参考。 对于每个物体，按照其面片（三角形）的顺序进行渲染。对于每个面片，通过逐像素扫描的方式进行渲染。 对于每个像素，计算它在相机空间中的深度值。 检查深度缓冲区中该像素的深度值，与当前计算得到的深度值进行比较。 如果当前深度值小于深度缓冲区中的值，表示该像素在当前面片前方，更新深度缓冲区的值，并使用当前面片的颜色值来更新屏幕上的像素颜色。 如果当前深度值大于或等于深度缓冲区中的值，表示该像素在其他面片前方或处于遮挡状态，不更新深度缓冲区和像素颜色，保留深度缓冲区中的值和之前的颜色。 重复步骤 4 和步骤 5，直到渲染完所有的物体和面片。 Z-buffer 算法伪代码 Z-buffer 例子 透明物体的深度问题(实际项目中碰到过) 在计算机图形学中，处理透明物体的深度排序和渲染是一个复杂的问题。传统的深度缓冲（Z-buffer）算法在处理透明物体时存在一些挑战，因为它们假设物体的渲染顺序是固定的，无法正确处理透明物体的交叠和混合效果。 以下是一些常见的方法用于解决透明物体深度排序的问题： 前向渲染（Forward Rendering）：在前向渲染中，透明物体按照离相机的距离进行排序，并按照顺序渲染到屏幕上。这样可以确保前面的透明物体覆盖后面的物体。然而，前向渲染需要对每个透明物体进行排序，增加了渲染的复杂性和计算开销。 深度排序算法（Depth Sorting Algorithms）：深度排序算法用于对透明物体进行排序，以便按正确的顺序渲染它们。常见的深度排序算法包括离相机距离排序、图元重排序（如 BSP 树、八叉树等）、Alpha 混合排序等。这些算法可以根据透明物体之间的相互遮挡关系和混合模式进行排序。 延迟混合（Deferred Blending）：延迟混合是一种用于处理透明物体的深度问题的技术。它通过将透明物体的颜色和深度信息存储在附加的缓冲区中，并在最后阶段进行混合操作。这样可以解决透明物体的深度排序问题，并且可以在片段着色器中使用透明度（Alpha）值进行混合计算。 顺序无关透明度（Order-Independent Transparency，OIT）：OIT 是一种使用多种技术来处理透明物体的深度问题的方法。它包括基于排序的方法、多层深度缓冲（如 Dual Depth Peeling）和基于像素的排序等。OIT 技术可以实现更高质量的透明效果，但通常需要更多的计算和内存开销。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-06-14 11:17:42 "},"pages/threeJS/Shading/":{"url":"pages/threeJS/Shading/","title":"Shading","keywords":"","body":"着色（Shading） 光照模型计算 在光照模型计算中，可以考虑光源的类型（如点光源、方向光源、环境光等）以及材质属性（如漫反射、镜面反射、环境反射等）。根据像素的位置、法线方向和光照参数，计算像素的漫反射和镜面反射颜色，以模拟光照效果。 Blinn-Phong 模型 Blinn-Phong 模型包含三部分：漫反射（Diffuse reflection） + 镜面反射（Specular highlights） + 环境光反射（Ambient lighting） 漫反射（Diffuse reflection） L_d = k_d \\cdot (I/r^2) \\cdot \\max(0, \\mathbf{n} \\cdot \\mathbf{l}) 镜面反射（Specular highlights） Phong 模型中的 v 和 R 半程向量 L_s = k_s \\cdot (I/r^2) \\cdot (\\max(0, \\mathbf{n} \\cdot \\mathbf{h}))^p 环境光反射（Ambient lighting） L_a = k_a \\cdot I_a 其中，k_a 是环境光系数，I_a 是环境光照强度。 Blinn-Phong 模型公式 L = L_a + L_d + L_s = k_a \\cdot I_a + k_d \\cdot (I/r^2) \\cdot (\\mathbf{n} \\cdot \\mathbf{l}) + k_s \\cdot (I/r^2) \\cdot (\\max(0, \\mathbf{n} \\cdot \\mathbf{h}))^p 着色频率 着色频率有三种：每个三角面着色、每个顶点着色、每个像素着色。 上面的 Blinn-Phong 模型针对的是物体表面一个单一的点，模型中的法向量很重要，不同的着色频率法向量的计算难度也不同： 三角面的法向量：\\vec {AB} \\cdot \\vec {AC} 顶点的法向量：与该顶点相连的多个三角面法向量加权平均 像素的法向量：通过对几何体的法向量进行插值，重⼼坐标插值（Barycentric Interpolation） 重⼼坐标（Barycentric Coordinates） 重心坐标必须满足两个条件： 重心坐标的值为非负数：u ≥ 0，v ≥ 0，w ≥ 0。 重心坐标的值之和为 1：u + v + w = 1。 插值的时候，u v w 都取 1/3 插值效果 重⼼坐标的应用 颜色插值和混合：如果像素的颜色是通过顶点着色插值得到的，片元着色阶段可以对这些颜色进行插值操作，以得到像素的最终颜色。此外，还可以进行颜色的混合操作，如透明度混合、颜色混合和阴影混合等。 法线插值和变换：对于法线映射和光照计算，片元着色阶段可以进行法线向量的插值操作，以在像素级别上模拟物体表面的细节。此外，还可以对法线进行变换，以适应不同的坐标系或局部坐标空间。 纹理映射 如果应用了纹理映射，片元着色阶段将进行纹理坐标的插值和采样操作。根据纹理坐标，在纹理图像中查找对应的颜色值，并将其应用到像素上。这允许在表面上显示出纹理、图案或图像。 纹理映射的问题：纹理太小，锯齿；纹理太大，摩尔纹、锯齿、过度模糊； 纹理太小问题 Texture Magnification：texture is too small 效果图 Nearest 插值：就近取值 Bilinear 插值：就近4个点双线性插值 Bicubic 插值：就近16个点插值 纹理太大问题 Texture Magnification：texture is too large 效果图 问题分析：本质就是采样问题，超采样可以解决问题，但是开销太大，更好的解决方案是：直接不采样，将采样的点查询换成范围查询。 Mipmaps：正方形范围查询 Mipmaps 图 Mipmaps 层级计算 Mipmaps 层级就近取整效果图 Mipmaps 不同层级之间的 Trilinear 插值计算过程 Mipmaps 层级 Trilinear 插值效果图 Ripmaps：矩形范围查询 Anisotropic Filtering: 各向异性过滤 EWA：不规则图形范围查询 EWA Filtering: 椭圆加权平均过滤 后期处理和特效 片元着色阶段还可以应用各种后期处理技术和特效，如景深效果、运动模糊、辉光、色彩校正等。这些技术可以在最后的渲染阶段对像素进行进一步的处理，以增强图像的质量和艺术效果 THREE.JS 的后期处理代码示例 import * as THREE from 'three' // 导入后期效果合成器 import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer' // three框架本身自带效果 import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass' import { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass' // 合成效果 const effectComposer = new EffectComposer(renderer) effectComposer.setSize(window.innerWidth, window.innerHeight) // 添加渲染通道 const renderPass = new RenderPass(scene, camera) effectComposer.addPass(renderPass) // 屏幕闪动 const glitchPass = new GlitchPass() effectComposer.addPass(glitchPass) const clock = new THREE.Clock() function animate() { const elapsedTime = clock.getElapsedTime() rawShaderMaterial.uniforms.uTime.value = elapsedTime animationID = requestAnimationFrame(animate) renderer && renderer.render(scene, camera) effectComposer.render() } animate() Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-07-13 11:15:54 "},"pages/threeJS/RayTracing/":{"url":"pages/threeJS/RayTracing/","title":"Ray Tracing","keywords":"","body":"光线追踪（Ray Tracing） Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-06-13 18:10:10 "},"pages/shader/":{"url":"pages/shader/","title":"Shader","keywords":"","body":"shader GLSL是什么？ GLSL 代表 openGL Shading Language，openGL 着色语言。根据硬件和操作系统的不同，还有其他的着色器（shaders)。 为什么 shaders 运行特别快? 并行处理: 比起用三五个强大的微处理器（或者说“管道”）来处理图形信息，用一大堆小的微处理器来并行计算，就要好得多。这就是图形处理器（GPU : Graphic Processor Unit)的来由。 内置数学函数: GPU 的魔法是特殊数学函数可通过硬件加速。非常复杂的数学操作可以直接被微芯片解决，而无须通过软件。这就表示可以有更快的三角和矩阵运算 —— 和电流一样快。 图形引擎：Metal(苹果)、DirectX(微软)、Vulkan(跨平台)。 为什么 Shaders 不好学？ 并行计算: 为了能使许多管线并行运行，每一个线程必须与其他的相独立。我们称这些线程对于其他线程在进行的运算是“盲视”的。这个限制就会使得所有数据必须以相同的方向流动。所以就不可能检查其他线程的输出结果，修改输入的数据，或者把一个线程的输出结果输入给另一个线程。允许数据在线程之间线程流动会使数据的整体性面临威胁。 GPU 会让所有并行的微处理器（管道们）一直处在忙碌状态；只要它们一有空闲就会接到新的信息。一个线程不可能知道它前一刻在做什么。它可能是在画操作系统界面上的一个按钮，然后渲染了游戏中的一部分天空，然后显示了一封 email 中的一些文字。每个线程不仅是“盲视”的，而且还是“无记忆”的。同时，它要求编写一个通用的规则，依据像素的不同位置依次输出不同的结果。这种抽象性，和盲视、无记忆的限制使得 shaders 在程序员新手中不是很受欢迎。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-02-27 09:31:50 "},"pages/shader/Syntax/":{"url":"pages/shader/Syntax/","title":"Syntax","keywords":"","body":"shader glsl 语法 三种限定符（uniform，attribute 和 varying） uniform(一致变量)：外部程序传递给（vertex 和 fragment）shader 的变量，不能被 shader 程序修改。 attribute(属性变量)：只能在vertex shader中使用的变量，一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。 varying(易变变量)：vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。 预处理命令 #define：宏定义，在编译处理阶段起作用。 #ifdef：判断一个宏定义是否存在，如果存在，在编译预处理的时候，保留 #ifdef 和 #endif 两个关键字之间的代码。 #if：判断条件是否成立，如果成立，在编译预处理后会保留通过 #if 和 #endif 两个关键字之间的代码，否在不保留。 #include：引入另一个着色器文件，在编译预处理后替换。 变量类型 标量 float: 浮点数 int: 整数 unit: 无符号整数 bool: 布尔值 矢量 vec3: 包含3个浮点数的矢量 ivec3: 包含3个整数的矢量 uvec3: 包含3个无符号整数的矢量 bvec3: 包含3个布尔值的矢量 矩阵 mat2: 2*2 的浮点数矩阵 mat3: 3*3 的浮点数矩阵 mat4: 4*4 的浮点数矩阵 取样器 纹理查找需要指定一个纹理或者纹理单元，GLSL不关心纹理单元的底层实现，因此它提供了 一个简单而不透明的句柄来封装需要查找的对象。这些句柄被称为\"取样器(SAMPLERS)\"。 sampler3D：访问三维纹理 samplerCube：访问立方贴图纹理 sampler2DRect：访问二维矩形纹理 sampler2DRectShadow：访问带对比的二维矩形深度纹理 sampler2DArrayShadow：访问二维深度纹理数组 samplerBuffer：访问纹理缓存 isampler3D：访问整型三维纹理 usampler3D：访问无符号整型三维纹理 结构 GLSL提供了类似于C 的用户定义结构。 struct light { vec3 position; vec3 color; } 数组 GLSL可以创建任何类型的数组。 创建的是一个包含 10 个 vec4 类型的数组：vec4 points[10]; 创建的是一个位置大小的 int 类型的数组：int num[]; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-02-15 10:36:59 "},"pages/shader/BuiltInFunction/":{"url":"pages/shader/BuiltInFunction/","title":"BuiltInFunction","keywords":"","body":"shader glsl 内置函数 官网文档地址：https://shaderific.com/glsl.html 1. 三角函数 这类主要是和角度相关的函数 函数 描述 sin(x) 正弦函数 cos(x) 余弦函数 tan(x) 正切函数 asin(x) 反正弦函数 acos(x) 反余弦函数 atan(x) 反正切函数 acot(x) 反余切函数 radians(x) 角度转换为弧度 degrees(x) 弧度转换为角度 2. 数学函数 这类主要是对指数对数幂函数的操作 函数 描述 pow(x,y) x的y次方。如果x小于0，结果是未定义的。同样，如果x=0并且y exp(x) e的x次方 log(x) 计算满足x等于e的y次方的y的值。如果x的值小于0，结果是未定义的。 exp2(x) exp2(x) 计算2的x次方 log2(x) 计算满足x等于2的y次方的y的值。如果x的值小于0，结果是未定义的。 sqrt(x) 计算x的开方。如果x小于0，结果是未定义的。 inversesqrt(x) 计算x的开方之一的值，如果x小于等于0，结果是未定义的。 3. 常用函数 常用函数，和js中的内置函数很像，必须掌握 函数 描述 abs(x) 返回x的绝对值 sign(x) 如果x>0，返回1.0；如果x=0，返回0，如果x floor(x) 返回小于等于x的最大整数值 ceil(x) 返回大于等于x的最小整数值 fract(x) 返回x-floor(x)，即返回x的小数部分 mod(x, y) 返回x和y的模 min(x, y) 返回x和y的值较小的那个值 max(x, y) 返回x和y的值较大的那个值 clamp(x, minVal, maxVal) 将x值钳于minVal和maxVal之间，意思就是当xminVal时返回minVal，当x>maxVal时返回maxVal，当x在minVal和maxVal之间时，返回x mix(x, y, a) 返回线性混合的x和y，如：x(1−a)+ya step(edge, x) step(edge, x) 如果x smoothstep(edge0, edge1, x) 如果x = edge1 返回1.0；如果edge0 = edge1，结果是未定义的。 4. 几何函数 这类主要是与长度、距离、向量等相关的函数 函数 描述 length(x) 返回向量x的长度 distance(p0,p1) 计算向量p0，p1之间的距离 dot 向量x，y之间的点积 cross(x, y) 向量x，y之间的叉积 normalize(x) 标准化向量，返回一个方向和x相同但长度为1的向量 faceforward(N, I, Nref) 如果Nref和I的点积小于0，返回N；否则，返回-N； reflect(I, N) 返回反射向量 refract(I, N, eta) 返回折射向量 5. 矩阵函数 函数 描述 matrixCompMult(A, B) 逐元素乘法 6. 向量函数 函数 描述 lessThan(a, b) \\vec a 与 \\vec b 逐元素小于 lessThanEqual(a, b) \\vec a 与 \\vec b 逐元素小于等于 greaterThan(a, b) \\vec a 与 \\vec b 逐元素大于 greaterThanEqual(a, b) \\vec a 与 \\vec b 逐元素大于等于 equal(a, b) \\vec a 与 \\vec b 逐元素相等 notEqual(a, b) \\vec a 与 \\vec b 逐元素不等于 any(a) \\vec a 任一元素为true，则为true all(a) \\vec a 所有元素为true 则为true not(a) \\vec a 逐元素取补 7. 纹理函数 函数 描述 texture2D(texture, uv) 在二维纹理(texture)中按照 uv 坐标获取纹素 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-05-06 14:53:00 "},"pages/shader/BuiltInVariable/":{"url":"pages/shader/BuiltInVariable/","title":"BuiltInVariable","keywords":"","body":"shader glsl 内置函数 官网文档地址：https://shaderific.com/glsl/variables.html 着色器的内置变量 gl_PointSize：在点渲染模式中，控制方形点区域渲染像素大小 gl_Position：控制顶点选完的位置 gl_FragColor：片元的RGB颜色值 gl_FragCoord：片元的坐标，同样是以像素为单位 gl_PointCoord：在点渲染模式中，对应方形像素坐标 gl_FrontFacing：改变渲染物体的 Front Facing 和 Back Facing Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-02-15 17:47:20 "},"pages/shader/Shapes/":{"url":"pages/shader/Shapes/","title":"Shapes","keywords":"","body":"Shapes 主要记录常用的形状写法：方形，圆形和三角形。 片元着色器书写的时候，需要注意的两点：1. 浮点数记得加小数点；2. 分号不能少。 Rectangle multiple 使用 uv 坐标的 x 和 y 分别与 特定的值进行 step 比较，然后让比较的结果相乘，利用 0 乘以任何值都为 0 的特性，把四边都变成黑色，中间的白色部分就形成了一个方形。 1.0 - st 计算的是上边和右边，因为 uv 的坐标原点在左下方。 step(0.4, st) 可以改成 step(vec2(0.4, 0.3), st)，就能画长方形了。 vec2 st = gl_FragCoord.xy / u_resolution.xy; // bottom-left vec2 bl = step(0.4, st); float pct = bl.x * bl.y; // top-right vec2 tr = step(0.4, 1.0 - st); pct *= tr.x * tr.y; vec3 color = vec3(pct); gl_FragColor = vec4(color, 1.); abs + max uv 坐标的 x 和 y 分别减去 0.5，将原点移动到中间（-0.5 to 0.5），然后分别求绝对值，再取最大值，得到的结果与固定数值进行 step 比较，小于固定数值的部分显示黑色，其余部分显示白色。 max 直接拿最大值进行比较，避免了分别比较还要相乘的算法，更高效。 uv 坐标的 x 和 y 分别减去 0.5, 将原点移动到中间，然后分别求绝对值，一次性计算四边，只能画正方形。 vec2 st = gl_FragCoord.xy / u_resolution.xy; float pct = step(0.1, max(abs(st.x - 0.5), abs(st.y - 0.5))); vec3 color = vec3(pct); gl_FragColor =vec4(color, 1.); 结合两种写法的优点 vec2 st = gl_FragCoord.xy / u_resolution.xy; vec2 uv = st - 0.5; vec2 pct = step(abs(uv), vec2(0.2, 0.3)); float strength = 1. - pct.x * pct.y; vec3 color = vec3(strength); gl_FragColor =vec4(color, 1.); Circle distance 利用 distance 计算不同两点的距离（像素坐标和画布中心的距离）。length（）函数内部只不过是用平方根(sqrt())计算斜边的方程。 就计算效率而言，sqrt()函数，以及所有依赖它的运算，都耗时耗力。 vec2 st = gl_FragCoord.xy / u_resolution.xy; float r = distance(st, vec2(0.5)); float c = 1.0 - step(0.5, r); vec3 color = vec3(c, 0.5, 0.5); gl_FragColor = vec4(color, 1.0); dot dot() 点乘是另外一种用来高效计算圆形距离场的方式。 本质：distance = sqrt((x-a)² + (y-b)²) => (x-a)² + (y-b)² vec2 st = gl_FragCoord.xy / u_resolution.xy; vec2 dist = st - 0.5; float r = 1. - step(0.5 * 0.5, dot(dist, dist)); vec3 color = vec3(r, 0.1, 0.1); gl_FragColor = vec4(color, 1.0); polar uniform vec2 u_resolution; uniform float u_time; vec2 cartesianToPolar(vec2 cartesian) { float radius = length(cartesian); float angle = atan(cartesian.y, cartesian.x); return vec2(radius, angle); } void main() { vec2 st = gl_FragCoord.xy / u_resolution.xy; vec2 center = vec2(0.5, 0.5); // 圆心位置 float radius = 0.4; // 圆的半径 // 将笛卡尔坐标转换为极坐标 vec2 polar = cartesianToPolar(st - center); // 判断当前像素是否在圆内 float insideCircle = step(polar.x, radius); // 设置圆的颜色 vec3 color = vec3(1.0, 0.0, 0.0); // 红色 // 根据像素是否在圆内来确定最终颜色 vec4 finalColor = vec4(color * insideCircle, 1.0); gl_FragColor = finalColor; } triangle glsl Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-05-06 17:53:39 "},"pages/shader/KeyPoints/":{"url":"pages/shader/KeyPoints/","title":"KeyPoints","keywords":"","body":"glsl 奇技淫巧 缩放 适用于水波纹，信号扩散等动效 代码举例 uniform float u_time; uniform sampler2D u_image; void main() { vec2 st = gl_FragCoord.xy / u_resolution.xy; vec4 color = texture2D(u_image, (st - 0.5) * (1. - fract(u_time)) * 10.0 + 0.5); gl_FragColor = color; } 简单说明： 无论是旋转还是缩放，都有一个中心点，在动画之前首先要将 st 平移到中心点（st - 0.5），动画之后再平移回来（+ 0.5）。 对于 texture2D(u_image, st)，st 是一个二维向量，st 乘以一个大于 1 的值，纹理贴图是在缩小；反之放大。 对于连续往返的动画，可以使用：abs(sin(u_time))；对于不连续的单向动画，可以使用：fract(u_time)。 旋转 适用于雷达扫描，特殊标注等动效 代码举例 uniform float u_time; uniform sampler2D u_image; vec2 rotateMat = mat2( cos(u_time), -sin(u_time), sin(u_time), cos(u_time) ); void main() { vec2 st = gl_FragCoord.xy / u_resolution.xy; vec2 newSt = rotateMat * (st - 0.5) + 0.5; vec4 color = texture2D(u_image, newSt); gl_FragColor = color; } 简单说明： 无论是旋转还是缩放，都有一个中心点，在动画之前首先要将 st 平移到中心点（st - 0.5），动画之后再平移回来（+ 0.5）。 旋转动画的核心就是这个旋转矩阵 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-07-07 11:29:49 "},"pages/3DDisplay/":{"url":"pages/3DDisplay/","title":"3D-Display","keywords":"","body":"Car 3D Display Summary [Draco] Draco 压缩与解压 [glTF] glTF 格式详解 [CSS3DRender] 3D 标注 [Raycaster] 射线点击事件 [Panorama] 全景图展示 [KeyboardControl] 键盘控制物体运动 [MaterialReset] 材质重置和批量处理 [Animation] 3D动画 [GuiControls] gui 调试工具 [Audio] 音频 [sRGBEncoding] sRGB 颜色空间 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-24 11:03:13 "},"pages/3DDisplay/Draco/":{"url":"pages/3DDisplay/Draco/","title":"Draco","keywords":"","body":"Draco 压缩 由于 3D 模型文件一般比较大，所以需要通过 Draco 压缩，以减少网络传输的大小。 方案一：gltf-pipeline npm 地址：https://www.npmjs.com/package/gltf-pipeline // 压缩 gltf 文件 npm i -g gltf-pipeline gltf-pipeline -i car.gltf -o copy.gltf -d // 解压 gltf 文件 import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js'; const loader = new GLTFLoader(); const dracoLoader = new DRACOLoader(); // 此处需要 'three/js/libs/draco/gltf/' 下的两个文件：draco_decoder.wasm + draco_wasm_wrapper.js dracoLoader.setDecoderPath('./draco/'); loader.setDRACOLoader(dracoLoader); loader.load('./gltf/copy.gltf', () => {...}); 方案二：google/draco github 地址：https://github.com/google/draco // 克隆仓库 git clone git@github.com:google/draco.git // 创建新文件夹 build mkdir build && cd build // 执行编译 cmake ../ // 执行 make make // 压缩文件 ./draco_encoder -i car.gltf -o copy.gltf Draco 的作用 Draco 在当前的VR、AR生态下，基本上没有直接使用的价值，想用它必须理解原理并修改源码。 Draco 里面有比较好的mesh压缩方案，有利于游戏引擎公司基于该代码优化自己的模型设计。 Draco 所能压缩的只是3D模型文件中的一部分，而3D相关的资源大头（图片）还是一个老大难的问题。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/glTF/":{"url":"pages/3DDisplay/glTF/","title":"glTF","keywords":"","body":"glTF glTF is the \"JPEG of 3D\" glTF 文件结构 glTF 内部结构详解 https://blog.csdn.net/qq_31709249/article/details/86477520 scenes： nodes： buffers： bufferViews： accessors： meshes： materials： textures： glTF 生态 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/CSS3DRender/":{"url":"pages/3DDisplay/CSS3DRender/","title":"CSS3DRender","keywords":"","body":"CSS3DRender 标注 在 3D 标注中，我们可以使用 CSS3DRenderer 来渲染 3D 标注。 刀片电池 单体电池长96mm、宽9mm、高1.35mm 可循环充放电3000次以上，续航600公里 import { CSS3DObject, CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer.js'; // 创建标注：将普通 html 转换为 3D 标注 const mark1 = document.getElementsByClassName('mark')[0]; mark1.style.visibility = 'visible'; const label1 = new CSS3DObject(mark1); mark1.style.pointerEvents = 'none'; label1.position.copy(LFSprite.position); label1.scale.set(0.5, 0.5, 1.0); label1.position.set(0, 0, 0); label1.position.x -= 220; label1.position.y += 50; label1.rotateY(-Math.PI / 2); model.add(label1); // 渲染 3D 标注 const labelRenderer = new CSS3DRenderer(); labelRenderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.domElement.style.position = 'absolute'; labelRenderer.domElement.style.top = '0px'; labelRenderer.domElement.style.left = '0px'; labelRenderer.domElement.style.pointerEvents = 'none'; document.body.appendChild(labelRenderer.domElement); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/Raycaster/":{"url":"pages/3DDisplay/Raycaster/","title":"Raycaster","keywords":"","body":"Raycaster 3D 点击事件 文档地址：https://threejs.org/docs/?q=Raycaster#api/zh/core/Raycaster intersectObject: 检测射线和单个物体的相交 intersectObjects: 检测射线和多个物体的相交 const mouse = new THREE.Vector2(-10000000, -1000000); let flag = false; const raycaster = new THREE.Raycaster(); const onDocumentClick = (event) => { flag = true; event.preventDefault(); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }; document.addEventListener('click', onDocumentClick, false); const render = () => { if (scene.children[6]) { raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(scene.children[6], true); if (intersects[0] && flag) { console.log('intersects', intersects[0]); if (intersects[0].object.parent.name === '左前门' || intersects[0].object.name === 'LFSprite') { if (LFDoor.flag) { LFDoor.rotateY(Math.sin(Math.PI / 2)); LFDoor.flag = false; } else { LFDoor.rotateY(-Math.sin(Math.PI / 2)); LFDoor.flag = true; } } flag = false; } } } requestAnimationFrame(render); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/MaterialReset/":{"url":"pages/3DDisplay/MaterialReset/","title":"MaterialReset","keywords":"","body":"MaterialReset 由于不同的 3D 制作软件渲染的效果有细微的差异，一般需要对材质属性进行重新设置。 metalness 材质与金属的相似度。 非金属材质，如木材或石材，使用0.0，金属使用1.0，通常没有中间值。 默认值为0.0。0.0到1.0之间的值可用于生锈金属的外观。 roughness 材质的粗糙程度。 0.0表示平滑的镜面反射，1.0表示完全漫反射。默认值为1.0。 envMapIntensity 通过乘以环境贴图的颜色来缩放环境贴图的效果。 transmission 透光率（或者说透光性），范围从0.0到1.0。默认值是0.0。 很薄的透明或者半透明的塑料、玻璃材质即便在几乎完全透明的情况下仍旧会保留反射的光线，透光性属性用于这种类型的材质。 当透光率不为 0 的时候, opacity 透明度应设置为 1. MeshPhysicalMaterial 特有。 例子 import * as THREE from 'three'; const SetCarMaterial = (carModel) => { const textureCube = new THREE.CubeTextureLoader() .setPath('./skybox/') .load(['li.jpg', 'xin.jpg', 'chu.jpg', 'xing.jpg', 'top.jpg', 'bottom.jpg']); textureCube.encoding = THREE.sRGBEncoding; carModel.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 4) === '高光金属') { object.material = new THREE.MeshStandardMaterial({ color: object.material.color, metalness: 1.0, roughness: 0.2, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 2) === '外壳') { object.material = new THREE.MeshPhysicalMaterial({ color: object.material.color, clearcoat: 1, clearcoatRoughness: 0.01, metalness: 1.0, roughness: 0.5, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 2) === '玻璃') { object.material = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0, transparent: true, transmission: 0.99, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 3) === '后视镜') { object.material = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.0, envMapIntensity: 1.0, }); } else if (object.name.slice(0, 2) === '轮胎') { object.material.color.set(0x000000); object.material.normalScale.set(2, 2); object.material.metalness = 0.0; object.material.roughness = 0.6; } else if (object.name.slice(0, 3) === '前灯罩') { object.material = new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0, transmission: 0.9, transparent: true, }); } else if (object.name.slice(0, 4) === '尾灯灯罩') { object.material = new THREE.MeshPhysicalMaterial({ color: 0xff0000, metalness: 0.0, roughness: 0, transmission: 0.5, transparent: true, }); } else if (object.name.slice(0, 5) === '尾灯第二层') { object.material = new THREE.MeshPhysicalMaterial({ color: 0x440000, metalness: 0.0, roughness: 0, transmission: 0.5, transparent: true, }); } else if (object.name.slice(0, 4) === '尾灯发光') { object.material = new THREE.MeshLambertMaterial({ color: 0x660000, }); } else if (object.name.slice(0, 5) === '尾灯第三层') { object.material = new THREE.MeshLambertMaterial({ color: 0x19190000, }); } else if (object.name.slice(0, 2) === '塑料') { object.material = new THREE.MeshPhysicalMaterial({ color: 0x010101, metalness: 0.0, roughness: 0.8, }); } carModel.getObjectByName('天窗黑玻璃').material = new THREE.MeshPhysicalMaterial({ color: 0x111111, metalness: 0.0, roughness: 0, envMapIntensity: 1.0, transmission: 0.5, transparent: true, }); carModel.getObjectByName('车座').material = new THREE.MeshPhysicalMaterial({ color: 0x020202, metalness: 0.0, roughness: 0.6, }); object.material.envMap = textureCube; } }); }; export default SetCarMaterial; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/Animation/":{"url":"pages/3DDisplay/Animation/","title":"Animation","keywords":"","body":"Animation tween.js is a powerful tool for creating interactive animations. 动画：旋转 + 平移 + 缩放 旋转: rotate // method Mesh.rotateY(-Math.sin(Math.PI / 2)); // attribute Mesh.rotation.y = -Math.sin(Math.PI / 2); 平移: translate // method Mesh.translateY(100); // attribute Mesh.position.y += 100; 缩放: scale // method Mesh.scaleY(1.5); // attribute Mesh.scale.y = 1.5; tween.js 文档地址：https://github.com/tweenjs/es6-tween/blob/HEAD/API.md 这个 npm 包已经停止维护了，但很好用。 import { Tween, Easing } from 'es6-tween'; let tween = null const rotateY = (value) => { // LFDoor 是需要旋转的 3D 对象 tween = new Tween(LFDoor.rotation) .to({ y: value }, 300) .easing(Easing.Exponential.In) .delay(100 * Math.random()) .start(); }; const render = () => { if (scene.children[6]) { raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(scene.children[6], true); if (intersects[0] && flag) { if (intersects[0].object.parent.name === '左前门' || intersects[0].object.name === 'LFSprite') { if (LFDoor.flag) { // LFDoor.rotateY(Math.sin(Math.PI / 2)); // LFDoor.rotation.y = 0; rotateY(0); LFDoor.flag = false; } else { // LFDoor.rotateY(-Math.sin(Math.PI / 2)); // LFDoor.rotation.y = -Math.sin(Math.PI / 2); rotateY(-Math.sin(Math.PI / 2)); LFDoor.flag = true; } } flag = false; } } if (tween) tween.update(); scene.rotateY(0.0005); renderer.render(scene, camera); requestAnimationFrame(render); } render(); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/GuiControls/":{"url":"pages/3DDisplay/GuiControls/","title":"GuiControls","keywords":"","body":"GuiControls 开发过程对参数的调试很麻烦，需要借助于 guiControls 调试具体参数。 其本质是一个简单的控制器，可以设置一个参数，然后调用一个函数，这个函数会改变参数的值。 例子 import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js'; import { model } from './Model.js'; /** * 创建一个gui对象 */ const guiControls = { envMapIntensity: 0.5, transmission: 0.5, metalness: 1.0, roughness: 0.5, }; const gui = new GUI(); gui.domElement.style = 'position: absolute; top: 0; right: 0; width: 300px;'; const folder1 = gui.addFolder('外壳'); folder1.open(); folder1.add(guiControls, 'envMapIntensity', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '外壳') { // eslint-disable-next-line no-param-reassign object.material.envMapIntensity = value; } } }); }); folder1.add(guiControls, 'metalness', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '外壳') { // eslint-disable-next-line no-param-reassign object.material.metalness = value; } } }); }); folder1.add(guiControls, 'roughness', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '外壳') { // eslint-disable-next-line no-param-reassign object.material.roughness = value; } } }); }); const folder2 = gui.addFolder('玻璃'); folder2.open(); folder2.add(guiControls, 'transmission', 0.0, 1.0).onChange((value) => { model.traverse((object) => { if (object.type === 'Mesh') { if (object.name.slice(0, 2) === '玻璃') { // eslint-disable-next-line no-param-reassign object.material.transmission = value; } } }); }); export default guiControls; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/Panorama/":{"url":"pages/3DDisplay/Panorama/","title":"Panorama","keywords":"","body":"Panorama 全景图展示 第三方插件：https://photo-sphere-viewer.js.org/guide/#install-photo-sphere-viewer 第三方插件的使用 import { Viewer } from 'photo-sphere-viewer'; import 'photo-sphere-viewer/dist/photo-sphere-viewer.css'; const viewer = new Viewer({ container: document.querySelector('#photosphere'), panorama: 'https://photo-sphere-viewer-data.netlify.app/assets/sphere.jpg', size: { width: window.innerWidth, height: window.innerHeight, }, defaultZoomLvl: 10, navbar: false, }); viewer.once('ready', () => { viewer.animate({ longitude: Math.PI, latitude: '20deg', zoom: 50, speed: '2rpm', }); }); 原理解析 原理非常简单：将全景图作为贴图贴到球面上，然后翻转球面，就可以实现全景图的展示。 const scene = new THREE.Scene(); const material = new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://photo-sphere-viewer-data.netlify.app/assets/sphere.jpg'), }); const size = 1000; const skyBox = new THREE.Mesh(new THREE.SphereBufferGeometry(size, size, size), material); skyBox.geometry.scale(-1, 1, 1); // 里外两侧的表面翻转 scene.add(skyBox); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/KeyboardControl/":{"url":"pages/3DDisplay/KeyboardControl/","title":"KeyboardControl","keywords":"","body":"KeyboardControl 控制物体的移动 three.js example 中的 KeyboardControl 代码 const keyboardControls = (function () { const keys = { SP: 32, W: 87, A: 65, S: 83, D: 68, UP: 38, LT: 37, DN: 40, RT: 39, }; const keysPressed = {}; (function (watchedKeyCodes) { const handler = function (down) { return function (e) { const index = watchedKeyCodes.indexOf(e.keyCode); if (index >= 0) { keysPressed[watchedKeyCodes[index]] = down; e.preventDefault(); } }; }; window.addEventListener('keydown', handler(true), false); window.addEventListener('keyup', handler(false), false); }([ keys.SP, keys.W, keys.A, keys.S, keys.D, keys.UP, keys.LT, keys.DN, keys.RT, ])); const forward = new THREE.Vector3(); const sideways = new THREE.Vector3(); let i = 0; let j = 0; return function () { // 观看 if (keysPressed[keys.UP]) { i += 1; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } if (keysPressed[keys.DN]) { i -= 1; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } if (keysPressed[keys.LT]) { j += 10; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } if (keysPressed[keys.RT]) { j -= 10; camera.lookAt(new THREE.Vector3(0, 30 + i, j)); } // 移动 if (keysPressed[keys.D]) { camera.translateX(10); } if (keysPressed[keys.A]) { camera.translateX(-10); } if (keysPressed[keys.W]) { camera.translateZ(-1); } if (keysPressed[keys.S]) { camera.translateZ(1); } }; }()); const render = () => { keyboardControls(); renderer.render(scene, camera); requestAnimationFrame(render); }; render(); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/Audio/":{"url":"pages/3DDisplay/Audio/","title":"Audio","keywords":"","body":"Audio 对于音频播放，可以借助于 html5 来实现，但是要创建 audio 标签，比较麻烦。可以直接使用 three 提供的 audio 模块。 API new THREE.AudioListener() -> 创建一个音频监听器。 new THREE.AudioLoader() -> 创建一个音频加载器，用于加载音频文件。 new THREE.Audio(listener) -> 创建一个音频对象，并且将其绑定到监听器，设置音量。 例子 import * as THREE from 'three'; const listener = new THREE.AudioListener(); const openAudio = new THREE.Audio(listener); const closeAudio = new THREE.Audio(listener); const audioLoader = new THREE.AudioLoader(); audioLoader.load('./audio/open.wav', (buffer) => { openAudio.setBuffer(buffer); openAudio.setVolume(1); }); audioLoader.load('./audio/close2.wav', (buffer) => { closeAudio.setBuffer(buffer); closeAudio.setVolume(1); }); const displayOpenAudio = () => { openAudio.play(); }; const displayCloseAudio = () => { closeAudio.play(); }; export { openAudio, closeAudio, displayOpenAudio, displayCloseAudio, }; Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/3DDisplay/Encoding/":{"url":"pages/3DDisplay/Encoding/","title":"sRGBEncoding","keywords":"","body":"THREE.sRGBEncoding 纹理中包含的颜色信息（.map, .emissiveMap, 和 .specularMap）在glTF中总是使用sRGB颜色空间，而顶点颜色和材质属性（.color, .emissive, .specular） 则使用线性颜色空间。在典型的渲染工作流程中，纹理会被渲染器转换为线性颜色空间，进行光照计算，然后最终输出会被转换回 sRGB 颜色空间并显示在屏幕上。 在使用 glTF 的时候将 WebGLRenderer 进行配置：renderer.outputEncoding = THREE.sRGBEncoding; /** * 创建渲染器对象 */ const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(width, height); renderer.outputEncoding = THREE.sRGBEncoding; renderer.setClearColor(0x00ffff, 1); 当从外部加载纹理（例如，使用 TextureLoader）并将纹理应用到 glTF 模型，则必须给定对应的颜色空间与朝向： carModel.traverse((object) => { if (object.type === 'Mesh') { if (object.name === '车标') { object.material.map = new THREE.TextureLoader().load('./gltf/Image_0.png'); object.material.map.encoding = THREE.sRGBEncoding; object.material.map.flipY = false; } } }); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/smartCity/":{"url":"pages/smartCity/","title":"Smart-City","keywords":"","body":"智慧城市总结 [Camera] 相机参数设置 [CurveWander] 曲线漫游 [automaticTransform] 自动轮播动画 [oribtControl] oribt 控制器 [gsap] gsap 动画库 [CSS2D] CSS2D 标签 [observeOperate] 监听用户是否有操作 [Stats] 性能监听检测 [GeoJson] 地理信息转 3D 模型 [WallEffects] 光墙特效 [Mercator] 墨卡托坐标 [optimization] 性能优化 [TechnologySelection] 技术选型 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-24 11:07:02 "},"pages/smartCity/camera/":{"url":"pages/smartCity/camera/","title":"Camera","keywords":"","body":"相机参数设置 开发过程中，往往会碰到模型已经加载成功但就是看不到效果，这是因为相机的参数设置不正确。 相机参数设置的步骤总结： 1.利用包围盒计算模型尺寸 2.模糊设置，根据模型尺寸设置相同数量级的参数 3.精确设置，利用 OrbitControls 动态调整，同时打印相机的位置。 包围盒的使用 注意：一定要等模型加载完成再计算包围盒。 /** * 包围盒计算模型大小 */ setTimeout(() => { const box3 = new THREE.Box3(new THREE.Vector3(-2, -2, -2), new THREE.Vector3(2, 2, 2)); box3.expandByObject(model); console.log('查看包围盒box3', box3); const v2 = new THREE.Vector3() box3.getCenter(v2) console.log('getCenter', v2); const v3 = new THREE.Vector3() box3.getSize(v3) console.log('查看返回的包围盒尺寸', v3); }, 3000) 相机设置 /** * 相机设置 */ const width = window.innerWidth; // 窗口宽度 const height = window.innerHeight; // 窗口高度 const camera = new THREE.PerspectiveCamera(30, width / height, 1, 30000); const E = 121.49526536464691; //东方明珠经纬度坐标 const N = 31.24189350905988; const xy = lon2xy(E, N); const x = xy.x; const y = xy.y; // camera.position.set(292, 223, 185);// 相机在Three.js三维坐标系中的位置 // camera.lookAt(0, 0, 0);// 相机指向Three.js坐标系原点 // camera.position.set(x + 5000, y + 5000, 5000);// 5000是根据建筑物尺寸范围设置 数量级对应即可 具体数值不用精准 camera.position.set(13524797, 3662134, 1220);//利用OrbitControls重新设置相机参数 调整视角 camera.lookAt(x, y, 0); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/smartCity/wander/":{"url":"pages/smartCity/wander/","title":"CurveWander","keywords":"","body":"相机漫游与物体追踪 日常开发过程中，我们经常会碰到相机漫游和驱使某个模型按照特定的路线移动的场景，而 curve.getSpacedPoints 能将曲线划分为多段生成一个数组，然后将相机的位置和模型的位置按照这个数组的数据依次变化。 曲线切段 const curve = new THREE.CatmullRomCurve3([ new THREE.Vector3(100, -50, 200), new THREE.Vector3(50, -50, -100), new THREE.Vector3(-300, -50, -200) ]) const points = curve.getSpacedPoints(3000) 移动相机和3D模型的位置 // 三维样条曲线 const curve = new THREE.CatmullRomCurve3([ new THREE.Vector3(100, -50, 200), new THREE.Vector3(50, -50, -100), new THREE.Vector3(-300, -50, -200) ]) //曲线上等间距返回多个顶点坐标 let time = 0 function moveCamera() { // 把曲线分割成2999段， 可以得到3000个点 const points = curve.getSpacedPoints(3000) // console.log({ points }) // 更新取点索引 time += 3 // 相机所在点索引 const index1 = time % 3000 // 前方机器人所在位置点的索引 const index2 = (time + 50) % 3000 // 根据索引取点 let point = points[index1] let point1 = points[index2] // 修改相机和模型位置 // console.log({ point }) if (point && point.x) { if (robot1) { robot1.position.set(point1.x, point1.y, point1.z) // robot1.lookAt(point.x, point.y, point.z) } camera.position.set(point.x, point.y, point.z) camera.lookAt(point1.x, point1.y, point1.z) } } 在 render 中调用 moveCamera 方法 const render = () => { // scene.rotateY(0.0005) renderer.render(scene, camera) // 执行渲染操作 moveCamera() camera.lookAt(scene.position) // console.log(camera.position) requestAnimationFrame(render) // 请求再次执行渲染函数render，渲染下一帧 } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-19 14:55:17 "},"pages/smartCity/automaticTransform/":{"url":"pages/smartCity/automaticTransform/","title":"automaticTransform","keywords":"","body":"自动轮播动画 迭代器循环任务 const task = [ { type: 'target', x: -500, y: 0, z: 500, time: 1000 }, { type: 'scale', x: -500, y: 0, z: 500, time: 2000 }, { type: 'target', x: -500, y: 0, z: 500, time: 3000 }, { type: 'scale', x: -500, y: 0, z: 500, time: 4000 } ] function* generatorEach(arr) { for (let [index, value] of arr.entries()) { yield setTimeout(() => { console.log([index, value]); const { done } = each.next(); if (done) { each = generatorEach(task); each.next(); } }, value.time) } } let each = generatorEach(task); each.next(); 实际案例 import gsap from 'gsap' import { camera } from './three' import { controls } from './controls' import { task } from '../config/task' import { selectedValue } from './webWorker/index' const task = [ { type: 'gsap', target: controls.target, obj: { x: -600, y: 0, z: 500 }, duration: 4 }, { type: 'gsap', target: camera, obj: { zoom: 20 }, duration: 3 }, { type: 'gsap', target: camera, obj: { zoom: 1 }, duration: 4 }, { type: 'gsap', target: controls.target, obj: { x: 50, y: 0, z: 0 }, duration: 4 }, { type: 'gsap', target: camera, obj: { zoom: 20 }, duration: 10 }, { type: 'rotate', duration: 30 }, { type: 'gsap', target: camera, obj: { zoom: 1 }, duration: 10 }, { type: 'gsap', target: controls.target, obj: { x: 600, y: 0, z: 500 }, duration: 4 }, { type: 'gsap', target: camera, obj: { zoom: 20 }, duration: 10 }, { type: 'rotate', duration: 30 }, { type: 'gsap', target: camera, obj: { zoom: 1 }, duration: 10 }, { type: 'gsap', target: controls.target, obj: { x: 600, y: 0, z: -500 }, duration: 4 }, { type: 'gsap', target: camera, obj: { zoom: 20 }, duration: 10 }, { type: 'rotate', duration: 30 }, { type: 'gsap', target: camera, obj: { zoom: 1 }, duration: 10 }, { type: 'gsap', target: controls.target, obj: { x: -600, y: 0, z: -500 }, duration: 4 }, { type: 'gsap', target: camera, obj: { zoom: 20 }, duration: 10 }, { type: 'rotate', duration: 30 }, { type: 'gsap', target: camera, obj: { zoom: 1 }, duration: 10 } ] const gsapPromise = (property: any, obj: any, duration: number) => { return new Promise((resolve, reject) => { gsap.to(property, { ...obj, duration, repeat: 0, yoyo: true, onComplete: () => { resolve(1) } }) }) } const rotatePromise = (duration: number) => { return new Promise((resolve, reject) => { controls.autoRotate = true const timer = setTimeout(() => { controls.autoRotate = false clearTimeout(timer) resolve(1) }, duration * 1000) }) } const switchFloorPromise = (target: string) => { return new Promise((resolve, reject) => { selectedValue.value = target const timer = setTimeout(() => { clearTimeout(timer) resolve(1) }, 2000) }) } let taskGenerator: any = null function* generatorEach(arr: any[]) { for (const [index, value] of arr.entries()) { yield (async () => { const { type, target, obj, duration } = value if (type === 'switch') { await switchFloorPromise(target) } else if (type === 'gsap') { await gsapPromise(target, obj, duration) } else if (type === 'rotate') { await rotatePromise(duration) } const { done } = taskGenerator.next() if (done) { taskGenerator = generatorEach(task) taskGenerator.next() } })() } } const animation = async () => { gsap.globalTimeline.play() controls.autoRotate = false taskGenerator = generatorEach(task) taskGenerator.next() } const rest = () => { controls.autoRotate = false gsap.globalTimeline.pause() } export { animation, rest } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-14 17:52:33 "},"pages/smartCity/oribtControl/":{"url":"pages/smartCity/oribtControl/","title":"oribtControl","keywords":"","body":"OrbitControls 文档：https://www.wenjiangs.com/doc/pipydiig http://events.jianshu.io/p/91165a6c49e4 平移：controls.target.set(0, 0, 0) 旋转: controls.autoRotate = true + controls.autoRotateSpeed = 2 缩放: camera.zoom = 2 状态：controls.saveState() + controls.reset() import * as THREE from 'three' import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' import { renderer, camera } from '../composables/three' // 创建控件对象 相机对象camera作为参数 控件可以监听鼠标的变化，改变相机对象的属性 const controls = new OrbitControls(camera, renderer.domElement) controls.enableDamping = true // an animation loop is required when either damping or auto-rotation are enabled controls.dampingFactor = 0.1 controls.rotateSpeed = 1.5 controls.zoomSpeed = 1.5 controls.panSpeed = 1.5 controls.autoRotate = true controls.autoRotateSpeed = 2 controls.enableZoom = true controls.screenSpacePanning = false controls.minDistance = 1 controls.maxDistance = 100000 // 修改鼠标事件 controls.mouseButtons = { LEFT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE } controls.saveState() export { controls } // controls.minZoom = 0.1 // controls.maxZoom = 1 // controls.maxPolarAngle = Math.PI / 2 // controls.minPolarAngle = 0 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-09 10:07:10 "},"pages/smartCity/gsap/":{"url":"pages/smartCity/gsap/","title":"gsap","keywords":"","body":"gsap https://greensock.com/docs/v3/GSAP https://www.bilibili.com/read/cv16848512/ import gsap from 'gsap' const gsapPromise = (property: any, obj: any, duration: number) => { return new Promise((resolve, reject) => { gsap.to(property, { ...obj, duration, repeat: 0, yoyo: true, onComplete: () => { resolve(1) } }) }) } export default gsapPromise Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-24 10:27:28 "},"pages/smartCity/CSS2D/":{"url":"pages/smartCity/CSS2D/","title":"CSS2D","keywords":"","body":"CSS2DObject + CSS2DRender 的基本使用和问题 CSS2D 和 CSS3D 标签的好处：点击事件稳定，使用也简单。 基本使用 import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer' const createTag = (object2d: any, type: string, obj: any) => { const element = document.createElement('div') element.className = 'elementTag' element.style.pointerEvents = 'auto' element.style.cursor = 'pointer' element.style.top = type === 'robot' ? '0px' : '-60px' element.innerHTML = ` ${obj.name} ` element.addEventListener('click', () => { popupVisible.value = true currentItem.value = obj }) const objectCSS2D = new CSS2DObject(element) objectCSS2D.position.copy(object2d.position) objectCSS2D.scale.set(0.2, 0.2, 0.2) return objectCSS2D } import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js' const labelRenderer = new CSS2DRenderer() labelRenderer.setSize(window.innerWidth, window.innerHeight) labelRenderer.domElement.style.position = 'absolute' labelRenderer.domElement.style.top = '0px' labelRenderer.domElement.style.left = '0px' labelRenderer.domElement.style.pointerEvents = 'none' if (carElement) carElement.appendChild(labelRenderer.domElement) 问题一：CSS2D 标签如果要添加点击事件，就会与3D场景中滚轮缩放事件冲突 import { ref } from 'vue' import { throttle } from 'lodash' const isOperating = ref(true) let timer: any = null const time = 30000 timer = setTimeout(() => { isOperating.value = false }, time) const observeOperate = (bool: boolean) => { // CSS2D 标签滚轮事件穿透与点击事件的切换 const CSS2DTags = document.getElementsByClassName('elementTag') for (let i = 0; i { isOperating.value = false }, time) } // 事件节流 document.body.onmousedown = throttle(() => { observeOperate(false) }, 1000) document.body.onwheel = throttle(() => { observeOperate(true) }, 1000) document.body.onmousemove = throttle(() => { observeOperate(false) }, 1000) export { isOperating } 问题二：CSS2D 标签残影竖线问题 避免使用 overflow: hidden 样式，即可修复问题 问题三：精灵图有黑色阴影和透明度的问题，CSS2D 是完美的解决方案（参考百度地图和高德地图的地理位置标识）。 import * as THREE from 'three' const createDock = () => { // 初始化geometry const geometry = new THREE.BufferGeometry() // 类型数组创建顶点数据 const arr = [] for (let i = 0; i Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-12-01 14:18:55 "},"pages/smartCity/chineseFont/":{"url":"pages/smartCity/chineseFont/","title":"chineseFont","keywords":"","body":"中文字体 three.js 加载中文字体比较麻烦，需要选对字体库 Facetype converts a font to a typeface.json font: http://gero3.github.io/facetype.js/ 找字体：https://www.zfont.cn/ 用法 const loaderFont = new THREE.FontLoader() const font = loaderFont.load( // resource URL '/self/fonts/pingfang_semibold.typeface.json', // onLoad callback (font) => { const fontMaterial = new THREE.MeshPhongMaterial({ color: '#33ff33', specular: '0xffffff', shininess: 30, emissive: 0xff0000 }) // const fontMaterial = new THREE.MeshPhysicalMaterial({ // color: '#33ff33', // metalness: 1.0, // roughness: 0.5, // envMapIntensity: 1.0, // emissive: 0x33ff33 // }) const text = new THREE.TextBufferGeometry('儿童输液放射科', { font: font, size: 14, height: 2, curveSegments: 12, bevelThickness: 10, bevelSize: 8, bevelEnabled: false }) text.center() text.scale(5, 5, 5) // text.rotateX(-Math.PI / 5) // text.rotateY(Math.PI / 4) let textFont = new THREE.Mesh(text, fontMaterial) scene.add(textFont) } ) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-01-05 09:57:39 "},"pages/smartCity/observeOperate/":{"url":"pages/smartCity/observeOperate/","title":"observeOperate","keywords":"","body":"监听用户是否正在操作页面 大屏开发一般会碰到这样的需求：用户一段时间不操作当前页面后就直接进入自动轮播状态。 import { ref } from 'vue' import { throttle } from 'lodash' const isOperating = ref(true) let timer: any = null const time = 30000 timer = setTimeout(() => { isOperating.value = false }, time) const observeOperate = (bool: boolean) => { // CSS2D 标签滚轮事件穿透与点击事件的切换 const CSS2DTags = document.getElementsByClassName('elementTag') for (let i = 0; i { isOperating.value = false }, time) } // 事件节流 document.body.onmousedown = throttle(() => { observeOperate(false) }, 1000) document.body.onwheel = throttle(() => { observeOperate(true) }, 1000) document.body.onmousemove = throttle(() => { observeOperate(false) }, 1000) export { isOperating } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-24 10:52:26 "},"pages/smartCity/colorDif/":{"url":"pages/smartCity/colorDif/","title":"colorDif","keywords":"","body":"深度排序问题 两个半透明的物体交织在一起的时候，由于深度排序问题，不同的角度看到的颜色差异较大。 解决方案一：使用不透明材质 不透明材质不具有透明度，只显示自身颜色，而不受背景颜色的影响。要使用不透明材质，可以将材质的 transparent 属性设置为 false。 const material = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: false }); 解决方案二：将背景颜色设置为与物体颜色相同的颜色 将背景颜色设置为与物体颜色相同的颜色，可以使物体的颜色看起来像是“挖空”了背景颜色，从而达到只显示物体颜色的效果。 const renderer = new THREE.WebGLRenderer(); renderer.setClearColor(0xff0000, 1); 解决方案三：使用深度测试 深度测试可以确保只有物体前面的像素才会被渲染，从而使物体的颜色看起来像是“遮挡”了背景颜色。要使用深度测试，可以将材质的 depthTest 属性设置为 true，同时设置 depthWrite 属性为 true。 const material = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: true, depthWrite: true }); 特别注意：此方案会形成黑色的背景块，需要使用方案四中的 alphaTest 属性来解决这个问题。 解决方案四：使用 alphaTest 属性，控制渲染时丢弃透明度低于特定值的像素。 const material = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, alphaTest: 0.01, depthTest: true, depthWrite: true }); 原理解析 三个关键属性的解析： depthTest: 深度测试属性。深度测试会根据场景中物体的距离来确定哪个物体在前面哪个物体在后面。开启深度测试可以避免绘制被遮挡的像素，从而提高渲染性能。当 depthTest 属性为 true 时，将使用 OpenGL 深度测试（即 z-buffering）算法来决定像素的可见性。 depthWrite: 深度写入属性。深度写入会将像素的深度信息写入深度缓冲区，以便进行深度测试。当 depthWrite 属性为 false 时，将禁止写入深度缓冲区，这意味着所有的像素都将被视为在场景中最靠近摄像机的物体，并且可能会覆盖其他物体。一般情况下，深度写入应该启用（即 depthWrite 设为 true）。 alphaTest: alpha 测试属性。alpha 测试会根据像素的 alpha 值来判断像素是否可见。当 alphaTest 属性大于等于 0 且小于 1 时，将使用 alpha 测试算法来决定像素的可见性。例如，当 alphaTest 属性为 0.5 时，只有像素的 alpha 值大于等于 0.5 时才会被视为可见像素，否则会被视为不可见像素。这个属性可以用于解决透明物体的渲染问题，例如在渲染玻璃、水面等透明物体时，可以将 alphaTest 属性设置为透明度阈值，以避免渲染过度的像素。 材质的 depthTest 属性为 true，表示开启深度测试。depthWrite 属性也为 true，表示允许写入深度缓冲区。alphaTest 属性为 0.2，表示只有像素的 alpha 值大于等于 0.2 时才会被视为可见像素，这样可以避免过度渲染半透明的像素。 现象一：黑色背景块 { depthTest: true, depthWrite: true }，有黑色背景块，半透明的像素被过度渲染。 现象二：色差明显 { depthTest: true, depthWrite: false }，禁止将像素的深度信息写入深度缓冲区，导致渲染引擎无法识别哪个半透明物体离相机近。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-04-28 15:53:06 "},"pages/smartCity/stats/":{"url":"pages/smartCity/stats/","title":"Stats","keywords":"","body":"stats 性能监听 随着模型的增大，网页无法承载大型模型的加载，需要实时监听网页运行的性能指标。 用法 import Stats from 'three/examples/jsm/libs/stats.module.js' const stats = new Stats() if (carElement) carElement.appendChild(stats.dom) const render = () => { // scene.rotateY(0.0005) renderer.render(scene, camera) // 执行渲染操作 moveCamera() camera.lookAt(scene.position) stats.update() // console.log(camera.position) requestAnimationFrame(render) // 请求再次执行渲染函数render，渲染下一帧 } 性能指标说明 帧数（FPS）：图形处理器每秒钟能够刷新几次，通常用FPS（Frames Per Second）来表示，越高的数字越好。 毫秒(MS)：渲染一个帧所需的 MS 毫秒，数字越小越好. MB ：已分配内存的 MB 字节（占用的内存大小） Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-20 14:55:30 "},"pages/smartCity/geoJson/":{"url":"pages/smartCity/geoJson/","title":"GeoJson","keywords":"","body":"geoJson 美术通过三维建模软件绘制，可以定制化模型，更加美观。但是如果场景特别多，美术绘制起来很费时，可以使用 geoJson 批量生成模型，然后对个别模型进行替换。 三维模型的绘制 美术通过3dmax、blender或其它任何三维建模软件绘制，然后导出常见格式，比如gltf，然后程序员使用three.js加载解析即可。 已知物体的几何数据，比如点云、长宽高、轮廓坐标等数据，可以使用three.js编写代码，解析已知的几何数据绘制三维模型。 geoJson 数据转换 shp 转 GeoJSON https://mapshaper.org/ 一个在线转格式平台 github代码地址：https://github.com/mbloch/mapshaper 文章提到过：https://blog.csdn.net/gisboygogogo/article/details/74056563 threejs 加载解析 shp 的库 shp.js github：https://github.com/kig/shp.js/ 链接：https://www.bram.us/2012/07/30/shp-js-javascript-shapefile-parser/ ShapeGeometry import * as THREE from 'three'; const model = new THREE.Group(); const shape = new THREE.Shape([ // 一个多边形轮廓的五个顶点坐标 new THREE.Vector2(0, 0), new THREE.Vector2(60, 0), new THREE.Vector2(60, 80), new THREE.Vector2(40, 120), new THREE.Vector2(-20, 80), ]); //ShapeGeometry：填充多边形 const geometry = new THREE.ShapeGeometry(shape); const material = new THREE.MeshLambertMaterial({ color: 0x00ffff, side:THREE.DoubleSide, // wireframe:true,//查看生成的三角形 }); //材质对象 const mesh = new THREE.Mesh(geometry, material); //网格模型对象 model.add(mesh); export default model ExtrudeGeometry import * as THREE from 'three'; const model = new THREE.Group(); //声明一个组对象，用来添加加载成功的三维场景 const shape1 = new THREE.Shape([ // 一个多边形轮廓的五个顶点坐标 new THREE.Vector2(0, 0), new THREE.Vector2(60, 0), new THREE.Vector2(60, 80), new THREE.Vector2(40, 120), new THREE.Vector2(-20, 80), ]); const shape2 = new THREE.Shape([ new THREE.Vector2(100, 0), new THREE.Vector2(160, 0), new THREE.Vector2(160, 80), new THREE.Vector2(140, 120), ]); //ShapeGeometry：填充多边形 const geometry = new THREE.ExtrudeGeometry([shape1, shape2], { depth: 50, //拉伸高度 bevelEnabled: false, //无倒角 }); const material = new THREE.MeshLambertMaterial({ color: 0x00ffff, side: THREE.DoubleSide, // wireframe:true,//查看生成的三角形 }); //材质对象 const mesh = new THREE.Mesh(geometry, material); //网格模型对象 model.add(mesh); export default model Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-15 12:35:19 "},"pages/smartCity/wallEffects/":{"url":"pages/smartCity/wallEffects/","title":"WallEffects","keywords":"","body":"光墙特效 把光线图片作为贴图赋给材质，然后通过 offset，进行平移动画，实现光墙特效。 import * as THREE from 'three' const texture = new THREE.TextureLoader().load('./3D/texture/light-line.png') // 设置阵列模式为 RepeatWrapping texture.wrapS = THREE.RepeatWrapping texture.wrapT = THREE.RepeatWrapping texture.repeat.x = 5 texture.repeat.y = 5 const flowAnimation = () => { requestAnimationFrame(flowAnimation) // texture.offset.y -= 0.02; texture.offset.x -= 0.02 } flowAnimation() const LR = buildingModel.getObjectByName('左右') if (LR) { LR.material = new THREE.MeshLambertMaterial({ color: 0xffff00, transparent: true, //允许透明计算 map: texture, opacity: 1, side: THREE.DoubleSide, depthTest: false }) } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-11-24 10:24:46 "},"pages/smartCity/mercator/":{"url":"pages/smartCity/mercator/","title":"Mercator","keywords":"","body":"mercator(墨卡托)坐标 墨卡托坐标系：展开地球，赤道作为x轴，向东为x轴正方，本初子午线作为y轴，向北为y轴正方向。 数字20037508.34是地球赤道周长的一半：地球半径6378137米，赤道周长2PIr = 2 * 20037508.3427892，墨卡托坐标x轴区间[-20037508.3427892,20037508.3427892] /** * 经纬度坐标转墨卡托坐标 * @param {经度(角度值)} longitude * @param {维度(角度值)} latitude */ const lon2xy = (longitude, latitude) => { const E = longitude; const N = latitude; const x = E * 20037508.34 / 180; let y = Math.log(Math.tan((90 + N) * Math.PI / 360)) / (Math.PI / 180); y = y * 20037508.34 / 180; return { x, // 墨卡托x坐标——对应经度 y, // 墨卡托y坐标——对应维度 } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-30 10:18:29 "},"pages/smartCity/optimization/":{"url":"pages/smartCity/optimization/","title":"optimization","keywords":"","body":"3D 项目性能优化 加载优化 1.缓存 2.路由懒加载 3.Web Worker glb 模型并发加载工作原理 web worker 可以解析 glb 模型 但是 postMessage 发送的数据类型只是普通的对象， 并且不能存在方法，方法无法传递，带方法会导致发送失败，并且不会触发 onerror THREE 构建物体所需的 bufferGeometry，还是 BufferAttribute 或者 Material 等原型对象无法被传递 传递到主线程的只是一个普通对象和上面的属性(对象中不能有函数) 可以通过生成一个 THREE 所需的类型 把传递过来的对象上的参数复制给 THREE 需要的对象上 这样在主线程生成一个同样的模型，但是省去了解析模型时间(模型解析在 web worker 中与 js 主线程并发执行)实现并发加载 创建 webworker 普通 worker 无法使用导入的库: 添加第二个参数 { type: 'module' } const worker = new Worker(new URL('../composables/task.ts', import.meta.url), { type: 'module' }) let model: any = null worker.onmessage = (event) => { console.log('webwork', event.data) model = parseModel(event.data) console.log({ model }) // scene.add(model) } worker.postMessage('floor') webworker 子线程任务 import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js' import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js' import setFloorMaterial from './setFloorMaterial' import { genAnimations, genGroupStruct } from './parse' const loader = new GLTFLoader() const dracoLoader = new DRACOLoader() dracoLoader.setDecoderPath('./3D/draco/') loader.setDRACOLoader(dracoLoader) onmessage = (e) => { const num = e.data console.log({ num }) loader.load( 'http://localhost:5173/3D/gltf/floor-1.glb', (gltf: any) => { // 材质重置 setFloorMaterial(gltf.scene) return postMessage({ ...genGroupStruct(gltf.scene), sceneAnimations: genAnimations(gltf.animations) }) }, (xhr: any) => { // console.log({ xhr }) }, (err: any) => { console.log({ err }) postMessage({ msg: 'Worker 模型加载错误！' + num }) } ) } 模型解析器 /** * 生成基本参数 旋转 位移 缩放等属性 */ const genBaseStruct = (obj: THREE.Object3D) => { const { type, name, quaternion: q, position: p, rotation: r, scale: s, up: u, userData, visible, matrix } = obj const quaternion = [q.x, q.y, q.z, q.w] const position = [p.x, p.y, p.z] const rotation = [r.x, r.y, r.z, r.order] const scale = [s.x, s.y, s.z] const up = [u.x, u.y, u.z] return { type, name, quaternion, position, rotation, scale, up, matrix, userData, visible, children: genObject3DChildren(obj.children), animations: genAnimations(obj.animations) } } /** * 生成动画结构 */ export const genAnimations = (animations: THREE.AnimationClip[]) => animations.map((animation) => { animation['tracks'].forEach((t) => delete t['createInterpolant']) return animation }) /** * 生成物体参数 */ const genMeshStruct = (mesh: THREE.Mesh) => { const { geometry, material } = mesh return { geometry, material, ...genBaseStruct(mesh) } } /** * 生成物体参数 */ const genLineSegmentsStruct = (lineSegments: THREE.LineSegments) => { const { geometry, material } = lineSegments return { geometry, material, ...genBaseStruct(lineSegments) } } const genPointLightStruct = (pointLight: THREE.PointLight) => { return { power: pointLight.power, color: pointLight.color, decay: pointLight.decay, castShadow: pointLight.castShadow, distance: pointLight.distance, frustumCulled: pointLight.frustumCulled, intensity: pointLight.intensity, layers: pointLight.layers, ...genBaseStruct(pointLight) } } const genObject3DStruct = (object: THREE.Object3D) => { return { ...genBaseStruct(object) } } /** * 生成子元素结构 */ const genObject3DChildren = (children: THREE.Object3D[]) => { const childStruct = [] for (const child of children) { const { type } = child if (type === 'Mesh') { childStruct.push(genMeshStruct(child as THREE.Mesh)) } else if (type === 'LineSegments') { childStruct.push(genLineSegmentsStruct(child as THREE.LineSegments)) } else if (type === 'Group') { childStruct.push(genGroupStruct(child as THREE.Group)) } else if (type === 'PointLight') { childStruct.push(genPointLightStruct(child as THREE.PointLight)) } else if (type === 'Object3D') { childStruct.push(genObject3DStruct(child)) } } return childStruct } /** * 生成物体组结构 */ export const genGroupStruct = (group: THREE.Group) => { const struct = { ...genBaseStruct(group) } return struct } 模型加载器 import * as THREE from 'three' import { THREEMaterialType, Vector3Arr, IBaseProps, IGroupParams, IMeshParams, IPointLight } from './types' /** * 通过设置attributes index来复刻一个集合体 */ const genGeometry = (geometry: IMeshParams['geometry']) => { const geom = new THREE.BufferGeometry() // const geom = new THREE.InstancedBufferGeometry() const { attributes: { position, uv, normal }, index } = geometry console.log({ position, uv, normal }) //处理几何坐标 const vertexBuffer = new THREE.InterleavedBuffer(position.data.array, 8) const positions = new THREE.InterleavedBufferAttribute(vertexBuffer, position.itemSize, position.offset, position.normalized) geom.setAttribute('position', positions) const uvs = new THREE.InterleavedBufferAttribute(vertexBuffer, uv.itemSize, uv.offset, uv.normalized) geom.setAttribute('uv', uvs) const normals = new THREE.InterleavedBufferAttribute(vertexBuffer, normal.itemSize, normal.offset, normal.normalized) geom.setAttribute('normal', normals) geom.setIndex(index ? new THREE.BufferAttribute(index.array, index.itemSize, index.normalized) : null) // const attributes = { // position: new THREE.BufferAttribute(position.data.array, position.itemSize, position.normalized), // uv: new THREE.BufferAttribute(uv.data.array, uv.itemSize, uv.normalized), // normal: new THREE.BufferAttribute(normal.data.array, normal.itemSize, normal.normalized) // } // geom.attributes = attributes // geom.index = index ? new THREE.BufferAttribute(index.array, index.itemSize, index.normalized) : null return geom } /** * 通过设置attributes index来复刻一个 LineSegments 集合体 */ const genLineSegmentsGeometry = (geometry: IMeshParams['geometry']) => { const geom = new THREE.BufferGeometry() // const geom = new THREE.InstancedBufferGeometry() const { attributes: { position } } = geometry // 处理几何坐标 geom.setAttribute('position', new THREE.BufferAttribute(position.array, position.itemSize, position.normalized)) return geom } /** * 根据传入纹理的参数生成真正有效的Material类型数据 */ const genMaterial = (mate: IMeshParams['material']) => { if (!mate) return undefined const multipleMaterial = Array.isArray(mate) const material = multipleMaterial ? ([] as THREE.Material[]) : new THREE[mate.type as THREEMaterialType]() //处理材质 //多个材质 if (multipleMaterial && Array.isArray(material)) { for (const m of mate) { const im = new THREE[m.type as THREEMaterialType]() material.push(im) } } else if (mate) { //单个材质 Object.assign(material, mate) } return material } /** * 处理基本属性转换(Object3D基类上的属性) matrix scale rotate translate position children animations */ const parseBaseParams = (params: IBaseProps, object: THREE.Object3D) => { const matrix = new THREE.Matrix4() matrix.elements = params.matrix.elements object.name = params.name object.matrix = matrix object.rotation.set(...params.rotation) object.position.set(...params.position) object.scale.set(...params.scale) object.quaternion.set(...params.quaternion) object.up.set(...params.up) object.userData = params.userData object.visible = params.visible parseChildren(object, params.children) genAnimations(object, params.animations) } const parseMesh = (IMeshParams: IMeshParams) => { const geometry = genGeometry(IMeshParams.geometry) const material = genMaterial(IMeshParams.material) const mesh = new THREE.Mesh(geometry, material) parseBaseParams(IMeshParams, mesh) return mesh } const parseLineSegments = (ILineSegments: IMeshParams) => { const geometry = genLineSegmentsGeometry(ILineSegments.geometry) const material = genMaterial(ILineSegments.material) const line = new THREE.LineSegments(geometry, material) parseBaseParams(ILineSegments, line) return line } const parseGroup = (params: IGroupParams) => { const group = new THREE.Group() parseBaseParams(params, group) return group } const parsePointLight = (params: IPointLight) => { const color = new THREE.Color() // 色彩空间 // export type ColorSpace = NoColorSpace | SRGBColorSpace | LinearSRGBColorSpace // export type NoColorSpace = '' // export type SRGBColorSpace = 'srgb' // export type LinearSRGBColorSpace = 'srgb-linear' //glb模型为了亮度恢复 使用srgb格式 所以颜色也使用同样格式 使其颜色模式一致 color.setRGB(params.color.r, params.color.g, params.color.b, 'srgb-linear') const pointLight = new THREE.PointLight(color, params.intensity, params.distance, params.decay) parseBaseParams(params, pointLight) return pointLight } const parseObject3D = (params: IBaseProps) => { const object = new THREE.Object3D() parseBaseParams(params, object) return object } const parseChildren = (object3D: THREE.Object3D, children: IBaseProps[]) => { if (!children.length) return const objectList: THREE.Object3D[] = [] for (const child of children) { const { type } = child if (type === 'Mesh') { objectList.push(parseMesh(child as IMeshParams)) } else if (type === 'LineSegments') { objectList.push(parseLineSegments(child as IMeshParams)) } else if (type === 'Group') { objectList.push(parseGroup(child)) } else if (type === 'PointLight') { objectList.push(parsePointLight(child as IPointLight)) } else if (type === 'Object3D') { objectList.push(parseObject3D(child)) } else { throw new Error('出现了未处理的类型：' + type) } } object3D.add(...objectList) } /** * 生成动画 */ const genAnimations = (object3D: THREE.Object3D, sceneAnimations: IGroupParams['sceneAnimations']) => { if (!sceneAnimations) return const animations: THREE.AnimationClip[] = [] for (const animation of sceneAnimations!) { const clip = new THREE.AnimationClip(animation.name, animation.duration, [], animation.blendMode) for (const { name, times, values } of animation.tracks) { const nreTrack = new THREE.QuaternionKeyframeTrack(name, times as any, values as any) clip.tracks.push(nreTrack) } animations.push(clip) } object3D.animations = animations } /** * 解析传入的模型参数生成有效的three.js物体 */ export const parseModel = (params: IGroupParams) => { const model = parseGroup(params) // model.position.x += 10 genAnimations(model, params.sceneAnimations) // console.log('解析完:', model) return model } 渲染优化 1.drawcall draw call 是指向图形处理器发出的绘制命令。每次调用 draw call，都会向 GPU 发送一组顶点和一组纹理，然后 GPU 根据这些数据绘制出一个三维物体。在绘制复杂的场景时，需要发出大量的 draw call，这可能会对性能产生负面影响 减少材质的数量：每个材质都需要单独的 draw call，因此减少材质的数量可以减少 draw call 的数量。 使用纹理图集：将多个纹理合并成一个纹理图集可以减少 draw call 的数量。 合并网格：如果多个网格具有相同的材质和纹理，则可以将它们合并成一个网格，以减少 draw call 的数量。 减少灯光的数量：每个灯光都需要单独的 draw call，因此减少灯光的数量可以减少 draw call 的数量。 减少透明度物体的数量：透明度物体需要进行混合和排序，这会导致更多的 draw call。因此，减少透明度物体的数量可以减少 draw call 的数量。 使用 LOD（层级细节）：使用 LOD 可以根据距离自动调整物体的细节级别。这可以减少细节不必要的物体的 draw call 数量。 使用批处理：批处理是将多个物体合并为一个 draw call 的技术。这可以大大减少 draw call 的数量，提高性能。 使用 GPU 实例化：GPU 实例化是在 GPU 上绘制多个相同的物体的一种技术，可以通过单个 draw call 来绘制多个实例，从而减少 draw call 的数量。 2.帧数优化 帧数（FPS）是衡量性能的重要指标。通常，较高的帧数意味着更流畅的体验和更好的游戏感觉。 内存优化 减少场景中的多边形数量：减少场景中的多边形数量可以降低内存使用量和渲染时间。可以使用多边形化工具来将复杂的几何体转换为简单的几何体，从而减少多边形数量。 使用纹理合集：使用纹理合集可以将多个纹理合并为一个，从而减少内存使用量。这可以通过使用纹理集来实现。 优化纹理大小：使用适当大小的纹理可以减少内存使用量。如果纹理大小过大，可以使用压缩技术将其压缩为较小的文件。 释放不需要的资源：在场景中使用的资源可以随着时间释放。可以根据需要在场景中加载和卸载资源，以避免浪费内存。 优化脚本：如果脚本在场景中消耗大量内存，则可以优化它们以减少内存使用量。可以尝试使用更少的变量、更少的递归和更好的内存管理技术。 基于 LOD 级别减少模型的细节：当模型距离相机越远时，可以逐步减少其细节级别，从而减少内存使用量。 使用模型复用：对于多个具有相似几何体的模型，可以使用模型复用，这样只需要存储一份几何体数据，可以在多个模型中共享。 禁用不必要的特性：如果某些特性不必要，则可以禁用它们以减少内存使用量。例如，可以禁用阴影、反射和抗锯齿等效果。 1.内存释放 onBeforeUnmount(() => { try { scene.clear() renderer.dispose() group.remove(buildingModel) group.remove(buildingModelWire) scene.remove(group) scene.remove.apply(scene, scene.children) renderer.forceContextLoss() renderer.content = null cancelAnimationFrame(animationID.value) const gl = renderer.domElement.getContext('Model') gl && gl.getExtension('WEBGL_lose_context').loseContext() } catch (e) { console.log(e) } }) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-03-13 15:09:27 "},"pages/smartCity/webGLContext/":{"url":"pages/smartCity/webGLContext/","title":"webGLContext","keywords":"","body":"webGL 上下文丢失 问题特征 网页 3D 部分的背景色是白色，非 3D 部分的 DOM 元素能正常显示。 问题报错，原因以及出现的场景 问题1：浏览器对 webGL 上下文个数的限制（google: 16） 问题报错：WARNING: Too many active WebGL contexts. Oldest context will be lost. 原因分析：浏览器同时支持的 WebGL context 个数是有限的，默认是16个。当超出时，会丢失之前创建的对象。 出现的场景： 通过 v-if 方式切换显示隐藏 3D 场景，或者 v-if 的判断字段与 3D 场景组件相关 路由页面跳转，但是没有主动销毁 3D 相关对象和内存释放 问题2：计算机进入休眠状态，导致 webGL 上下文数据丢失 问题报错： WebGL error CONTEXT_LOST_WEBGL in uniformMatrix4fv([object WebGLUniformLocation, false, [object Float32Array]) WAENING: WebGL content on the page might have caused the graphics card to reset 原因分析：WebGL使用了计算机的图形硬件，而这部分资源是被操作系统管理，由包括浏览器在内的多个应用程序共享。如果一个程序接管了图形硬件，或者操作系统进入休眠，浏览器就会失去使用这些资源的权力，并导致存储在硬件中的数据丢失。在这种情况下，WebGL绘图上下文就会丢失。 解决方案 通过 v-show, opcity, visibility 或者离屏渲染等方式频繁切换显示隐藏 3D 场景 webGL 提供供了两个事件来表示这种情况: 上下文丢失时触发: webglcontextlost 上下文恢复事件: webglcontextrestored const gl = renderer.getContext() gl.canvas.addEventListener( 'webglcontextlost', () => { location.reload() }, false ) 主动销毁 3D 相关对象和内存释放 onBeforeUnmount(() => { try { scene.clear() renderer.dispose() group.remove(buildingModel) group.remove(buildingModelWire) scene.remove(group) scene.remove.apply(scene, scene.children) renderer.forceContextLoss() renderer.content = null cancelAnimationFrame(animationID.value) const gl = renderer.domElement.getContext('Model') gl && gl.getExtension('WEBGL_lose_context').loseContext() } catch (e) { console.log(e) } }) 总结 webGL 上下文是一个相对复杂的对象，一旦 webGL 上下文丢失，它就无法再使用，因此必须在丢失事件发生时及时释放所有相关资源并重新创建一个新的 webGL 上下文。所以要时刻关注 webGL 上下文对象并主动释放内存，防止内存泄露和 webGL 上下文丢失。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-03-15 09:59:07 "},"pages/smartCity/ourBIM/":{"url":"pages/smartCity/ourBIM/","title":"TechnologySelection","keywords":"","body":"项目选型 建模选型 视频介绍：https://www.bilibili.com/video/BV1pe4y1k7JE/?is_story_h5=false&p=1&share_from=ugc&share_medium=android&share_plat=android&share_session_id=b47e229e-53d7-4c1d-9f87-b53002b5be89&share_source=WEIXIN&share_tag=s_i&timestamp=1663801154&unique_k=dinnZLv BIM 建模: 精度高，项目交付高标准，建模周期长（2-3个月）。 图纸建模: 项目交付标准一般，建模周期根据精度可控。 逆向建模: 倾斜摄影 + 激光点云，需后期修图。 渲染技术选型 云端渲染: 1.服务器端渲染 + webRTC + api接口；2.受制于服务商 webGL 网页渲染: 1.模型分开建模，单个模型不能太大；2.性能问题自己控制 客户端渲染(引擎改良): 1.不用考虑性能问题；2.受制于服务商 ourBIM 会议记录 参会人员 于浩、刘利、曹沙、唐勇、陈小鹃、牛经理 技术架构说明 优劣势分析 优势 效率：实时云端渲染对客户端配置要求低。 时间：在医院能提供 BIM 模型的情况下，开发周期短。 劣势 费用：私有云部署费用高(50w)，后期升级收取费用15%。 未来可能有部分自定义功能不能实现，受制于服务商。 会议结论 可以先尝试使用免费版做一个小 demo，作为备选方案。 在医院能提供 BIM 模型的情况下，开发周期短，2周左右。 整体结论（个人建议） 适当降低交付标准，建模根据图纸手动建模，采用 webGL 网页渲染。 有利于未来根据激光点云快速建模，快速交付以后的项目 技术沉淀，自己搭建云端渲染应用 具体实现： 3栋建筑整体建模，只识别楼栋 单栋建筑建模，识别楼层 单层建筑，识别细节 方案对比 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-03-13 10:46:57 "},"pages/webGPU/":{"url":"pages/webGPU/","title":"webGPU","keywords":"","body":"webGPU Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-05-31 09:42:40 "},"pages/webGPU/document/":{"url":"pages/webGPU/document/","title":"document","keywords":"","body":"webGPU document https://developer.mozilla.org/zh-CN/docs/Web/API/WebGPU_API https://github.com/gpuweb/gpuweb Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-05-31 09:51:53 "},"pages/cesium/":{"url":"pages/cesium/","title":"Cesium","keywords":"","body":"Cesium Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-07-03 16:22:04 "},"pages/cesium/shader/":{"url":"pages/cesium/shader/","title":"Custom","keywords":"","body":"Cesium 中的自定义着色器代码 Cesium 中有三个地方可以直接编写着色器代码： entities 自定义材质 primitive 自定义材质 primitive 自定义外观 entities 自定义材质 const viewer = new Cesium.Viewer('container', { animation: false, baseLayerPicker: false, // geocoder: false, homeButton: false, infoBox: false, sceneModePicker: false, timeline: false, navigationHelpButton: false, antialias: true, }) // 隐藏logo viewer.cesiumWidget.creditContainer.style.display = \"none\" // 添加实体 class CustomMaterialPropery { constructor() { this.definitionChanged = new Cesium.Event(); Cesium.Material._materialCache.addMaterial(\"CustomMaterial\", { fabric: { type: \"CustomMaterial\", uniforms: { uTime: 0, }, source: ` czm_material czm_getMaterial(czm_materialInput materialInput) { // 生成默认的基础材质 czm_material material = czm_getDefaultMaterial(materialInput); material.diffuse = vec3(materialInput.st, uTime); material.alpha = 0.5; return material; } `, }, }); this.params = { uTime: 0, }; gsap.to(this.params, { uTime: 1, duration: 2, repeat: -1, yoyo: true, }); } getType() { // 返回材质类型 return \"CustomMaterial\"; } getValue(time, result) { result.uTime = this.params.uTime; // 返回材质值 return result; } } let material = new CustomMaterialPropery(); const rectangle = viewer.entities.add({ id: \"entityRect\", rectangle: { coordinates: Cesium.Rectangle.fromDegrees( // 西边的经度 100, // 南边维度 20, // 东边经度 120, // 北边维度 30 ), // 设置entity材质，MaterialProperty // material: Cesium.Color.BLUE.withAlpha(0.5), // height: 3000, material, }, }); primitive 自定义材质 const viewer = new Cesium.Viewer('container', { animation: false, baseLayerPicker: false, // geocoder: false, homeButton: false, infoBox: false, sceneModePicker: false, timeline: false, navigationHelpButton: false, antialias: true, }) // 隐藏logo viewer.cesiumWidget.creditContainer.style.display = \"none\" // 添加 primitive // 01-创建几何体 let rectGeometry = new Cesium.RectangleGeometry({ rectangle: Cesium.Rectangle.fromDegrees( // 西边的经度 121, // 南边维度 20, // 东边经度 122, // 北边维度 30 ), // 距离表面高度 height: 0, vertexFormat: Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT, }); // 02-创建几何体实例 let instance = new Cesium.GeometryInstance({ id: \"redRect\", geometry: rectGeometry, attributes: { color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.RED.withAlpha(0.5) ), }, }); let material = new Cesium.Material({ fabric: { uniforms: { uTime: 0, }, source: ` czm_material czm_getMaterial(czm_materialInput materialInput) { // 生成默认的基础材质 czm_material material = czm_getDefaultMaterial(materialInput); // material.diffuse = vec3(materialInput.st+uTime, 0.0); float strength = mod((materialInput.st.y - uTime) * 2.0, 1.0); material.diffuse = vec3(strength, 0.0, 0.0); return material; } `, }, }); // 03-外观 let appearance = new Cesium.EllipsoidSurfaceAppearance({ material, aboveGround: false, translucent: true, }); appearance.uniforms = { uTime: 0, }; gsap.to(appearance.uniforms, { uTime: 1, duration: 2, repeat: -1, yoyo: true, ease: \"linear\", }); // 04-图元 let primitive = new Cesium.Primitive({ geometryInstances: [instance], appearance: appearance, show: true, }); // 05-添加到viewer viewer.scene.primitives.add(primitive); primitive 自定义外观 const viewer = new Cesium.Viewer('container', { animation: false, baseLayerPicker: false, // geocoder: false, homeButton: false, infoBox: false, sceneModePicker: false, timeline: false, navigationHelpButton: false, antialias: true, }) // 隐藏logo viewer.cesiumWidget.creditContainer.style.display = \"none\" // 添加 primitive // 01-创建几何体 let rectGeometry = new Cesium.RectangleGeometry({ rectangle: Cesium.Rectangle.fromDegrees( // 西边的经度 121, // 南边维度 20, // 东边经度 122, // 北边维度 30 ), // 距离表面高度 height: 0, vertexFormat: Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT, }); // 02-创建几何体实例 let instance = new Cesium.GeometryInstance({ id: \"redRect\", geometry: rectGeometry, attributes: { color: Cesium.ColorGeometryInstanceAttribute.fromColor( Cesium.Color.RED.withAlpha(0.5) ), }, }); // 03-外观 let appearance = new Cesium.EllipsoidSurfaceAppearance({ aboveGround: false, translucent: true, fragmentShaderSource: ` in vec3 v_positionMC; in vec3 v_positionEC; in vec2 v_st; uniform float uTime; void main() { czm_materialInput materialInput; out_FragColor = vec4(v_st, 0.5, 1.0); } `, }); appearance.uniforms = { uTime: 0, }; gsap.to(appearance.uniforms, { uTime: 1, duration: 2, repeat: -1, yoyo: true, ease: \"linear\", }); // 04-图元 let primitive = new Cesium.Primitive({ geometryInstances: [instance], appearance: appearance, show: true, }); // 05-添加到viewer viewer.scene.primitives.add(primitive); Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-07-03 16:40:05 "},"pages/cesium/event/":{"url":"pages/cesium/event/","title":"Event","keywords":"","body":"鼠标事件监听 类似于 three.js 的 Raycaster 3D 鼠标事件，cesium 也有自己特有的鼠标事件监听器。 代码示例 const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas); handler.setInputAction((movement) => { // 获取鼠标的坐标 const cartesian = viewer.camera.pickEllipsoid( movement.endPosition, viewer.scene.globe.ellipsoid ); if (cartesian) { // 转换成经纬度 const cartographic = Cesium.Cartographic.fromCartesian(cartesian); const longitudeString = Cesium.Math.toDegrees( cartographic.longitude ).toFixed(5); const latitudeString = Cesium.Math.toDegrees( cartographic.latitude ).toFixed(5); const heightString = cartographic.height; // 显示经纬度 console.log( `经度：${longitudeString} 纬度：${latitudeString} 高度：${heightString}` ); } }, Cesium.ScreenSpaceEventType.MOUSE_MOVE); 实现步骤 step-1: 创建一个 ScreenSpaceEventHandler 对象，并传入 viewer.scene.canvas 作为参数，这将绑定事件处理程序到 Cesium 的渲染画布。 step-2: 使用 setInputAction 方法来设置事件处理程序。它接受两个参数：一个回调函数和一个指定事件类型的常量。 handler.setInputAction((movement) => { // 在这里编写处理鼠标移动事件的代码 }, Cesium.ScreenSpaceEventType.MOUSE_MOVE); step-3: 编写回调函数，可以通过movement.endPosition获取鼠标当前的屏幕坐标。然后，使用viewer.camera.pickEllipsoid方法将屏幕坐标转换为地球上的笛卡尔坐标。 const cartesian = viewer.camera.pickEllipsoid( movement.endPosition, viewer.scene.globe.ellipsoid ); step-4: ScreenSpaceEventType 常量 姓名 描述 LEFT_DOWN 表示鼠标左键按下事件。 LEFT_UP 代表鼠标左键按下事件。 LEFT_CLICK 代表鼠标左键单击事件。 LEFT_DOUBLE_CLICK 代表鼠标左键双击事件。 RIGHT_DOWN 表示鼠标左键按下事件。 RIGHT_UP 代表鼠标右键按下事件。 RIGHT_CLICK 代表鼠标右键单击事件。 MIDDLE_DOWN 表示鼠标中键按下事件。 MIDDLE_UP 代表鼠标中键弹起事件。 MIDDLE_CLICK 代表鼠标中键单击事​​件。 MOUSE_MOVE 代表鼠标移动事件。 WHEEL 代表鼠标滚轮事件。 PINCH_START 表示触摸表面上两指事件的开始。 PINCH_END 表示触摸表面上的两指事件的结束。 PINCH_MOVE 表示触摸表面上两指事件的变化。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2023-07-07 10:47:51 "}}